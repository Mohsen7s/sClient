HOOK_RETRACTED=-1
HOOK_IDLE=0
HOOK_RETRACT_START=1
HOOK_RETRACT_END=3
HOOK_FLYING = 4
HOOK_GRABBED = 5
	
--'gazanfaṛ'
--88478003



SashExeVer = '1.5.7, Oct  1 2020, 14:15:35'
SashDebugIgnoreVer = false

lastFakeVerString = 12099



--SashTrialLicense = nil
SashTrialLicense = nil
SashRunTime = Game.Client.LocalTime
listOfLiceses = {}

--E4F042ACB9023470B0A4BB4039788860DB9A3170C620C69870720C207E0A7B60AC1C90E875A0ABA0B89C395C8FE872000A52D0E43450BA683DBE24C87054C900
listOfLiceses[#listOfLiceses+1] = 
{
	--free lic
	key = "Z+Y/+-^\\]&/-,+(/]/^+]]+/,&(''')/[]&^,.(/\\)-/\\)&'(/(-/\\-/(Z/^(])/^\\.\\&/Z'(*^/^]^/]'&\\,&*\\'YZ'(-///^*-[/Z+,+*/]^)',[]Z-+\\'(/*+\\&//",
	owner = 'Mohsen'
}

--ECD8A6802452C8308C90FA04085A6700324884708A400C48389CA460360AD860494076901C086E00F43EA808BC307210A8662B80BAD8B4A052C0DC34188CB100
listOfLiceses[#listOfLiceses+1] = 
{
	--us lic 100 USD
	key = "['&/,^/+*])^-/['Z&(^\\.Z+[*(//[//.Y'+.Z+'Y+&+]*&/Y,Y/.'\\'[[--Y&//*]Z-^]Z\\(Y&),'(']/]))),')-(''-&/-)Z)/'^/*)])Z&''Z/[Z[][\\.(*'^^\\/", 
	owner = 'Nin_'
}
 
listOfLiceses[#listOfLiceses+1] = 
{
	--us lic 100 USD
	key = "/++-]+Y+.'+^*/('^(&/Z+./(['',\\+/++*-(+\\+&']^*/)'&(./^+[/'[+'(\\'/'+)-,+&+.'-^*/*''(&/)+&/&[/']\\\\/\\+(-Y+)+&'&^*/+'((./-+*/^[\\'Y\\//", 
	owner = 'd00moW'
}

listOfLiceses[#listOfLiceses+1] = 
{
	--us lic 100 USD
	key = "['&/,^/+*]^),Y*/,Y\\''(\\\\\\,&^&+]/(*[//]Y'/&'),Y/''&Y/.'\\'[[---Y-/+^ZZ]\\(+(*,^^[Z/Z,.-]'/\\^Z^)'(]/.].-/'^/*)])Z&]'/.++&[]/).//[*+/", 
	owner = 'Save Da Beez'
}

listOfLiceses[#listOfLiceses+1] = 
{
	--ir lic 1 mil
	--admin sash irani
	--D8903A045B580EF836BEB32C16BA3B10B9E2BF0CDBC89B38F3F018C8DD229C40FFCC99045D543D48D9BAE35CDB7214707DE608A056B6E9E07206627455305700
	--D8903A045B5290B88B143AE0C8587710B918D2F81EECE3A825F018C8DD227D00D746467888702CE8D9BA6488AED43EF0574A08A056B6E9A870F60178B6DAE140
	--key = "['&/,^/+*]*'/ZY',)]Z],-\\.)]^,]./]&Z-]Y/\\[]\\'&],'Y,Y/.'\\'[[--&\\+/YY\\\\&&/+*[*+,[+'[&]^Z,*\\[](-.+(/([Z)/'^/*)])Z&Z/(-/))-(+**,/*(//",
	key = "['&/,^/+*]*-&/]''].+,^Z/\\'*'((./]&.'[-Y'.ZZ\\Z,^'-*Y/.'\\'[[--([//[(+)+)('''(/-\\Z'[&]^)+''^Z[+,ZY/*(+^/'^/*)])Z&^'(/Y)/.('])[^Z.+/",
	owner = 'г-н.вирус'
}

 
listOfLiceses[#listOfLiceses+1] = 
{
	--us lic 100 USD
	key = "\\Z&),+(\\*)()-^('(*Z\\+*.'*]\\Z]-]/(*&^.ZY'(^[\\/)*/[,.''*+')*]+Y.^/]Z]Z+)Y\\\\*[+'[\\'Z[Z+)-.'\\-/\\[-./Y\\'Z,^*+,Z)^\\]&/,((+&[]\\Y)&^Y\\+/", 
	owner = 'Cocain'
}


listOfLiceses[#listOfLiceses+1] = 
{
	--us lic 25 USD!
	key = "[]\\-'*-\\)*\\+(/)/+[\\-Z+.\\].]\\-\\./[Y))],\\\\^(*).^'/+\\\\-]Y[/.&,)/Z'/-.]ZY.^+.,--+((/&/,',(]\\]\\.)]])/[+,-&[(\\&**^&[,'\\)^/-+^\\]&)+/+'/", 
	owner = 'ehsan'
}



listOfLiceses[#listOfLiceses+1] = 
{
	--us lic 25US
	key = "['&/,^/+*]Y+.\\*/)())[^(')/*'YY]/(*.'Y'*\\/*+\\'.\\'^-Y/.'\\'[[--\\-'/+^]Z)*Y',-+/-\\^'Z,.-)+Z/'Y\\Z-Z*/^,++/'^/*)])Z&&/Z+++.*)+.)*'Z&+/", 
	owner = 'emlll'
}


listOfLiceses[#listOfLiceses+1] = 
{
	--us lic 25 USD
	key = "['&/,^/+*][\\[)&/),.+Z^(\\']//\\-]/(*^\\.Z&'\\^\\Z[*+/''+\\*])+*-+\\-Z)/+-]\\(Y]\\//(+'[\\'.)Z+]^['].^^^''/*Z]-)[\\'\\-\\\\*[(/'Z'-Z[//-)'^Y''/", 
	owner = 'FE7R'
}


listOfLiceses[#listOfLiceses+1] = 
{
	--us lic 25 USD
	key = "[]\\-'*-\\)*\\+(/)/+[\\-Z+.\\].]\\-\\./[Y))],\\\\^(*).^'/+\\\\-]Y[/.&,)/Z'/-.]ZY.^+.,--+((/&/,',(]\\]\\.)]])/[+,-&[(\\&**^&[,'\\)^/-+^\\]&)+/+'/", 
	owner = 'Technoo'
}


--


--[[
 auto exe updater

 ba reset profile

 auto find and hook in air and let unfreeze players
 
 hud activated tools
]]--#


--[[#!
	#io
	#os
	#ffi
	#debug
	#package
]]--#


local TeeSize = 28
local TileSize = 32

bit = require 'bit'
bitser = require 'bitser'
fs = require 'fs'
--
zip = require 'minizip'
mlib = require 'mlib'

BotRectArray = {}
BotRectArrayCount = 0

BotEditRectArray = {}
BotEditRectArrayCount = 0

availRecPosArray = {}

stackRequestLastPage = nil

lastInputData = {}
lastInputData[0] = {
	Direction       = 0, 
	Fire            = 0, 
	Hook            = 0, 
	Jump            = 0, 
	WantedWeapon    = 0, 
	TargetX         = 0, 
	TargetY         = 0, 
	MouseX          = 0, 
	MouseY          = 0, 
	Flags 			= 0,
	NextWeapon		= 0,
	PreviousWeapon	= 0
}

lastInputData[1] = {
	Direction       = 0, 
	Fire            = 0, 
	Hook            = 0, 
	Jump            = 0, 
	WantedWeapon    = 0, 
	TargetX         = 0, 
	TargetY         = 0, 
	MouseX          = 0, 
	MouseY          = 0, 
	Flags 			= 0,
	NextWeapon		= 0,
	PreviousWeapon	= 0
}
	
function MakeAButton( inType, inScreen, BtnText, BtnRect, BtnTip, BtnAction, isChecked, BtnNedlePer, BtnMaxValue  )
	local ButtonData = {
		Screen = inScreen,
		BC = NextBC(),
		Text = BtnText,
		Clicked = isChecked or false,
		Action = BtnAction,
		Rect = BtnRect:copy(),
		Tip = BtnTip,
		Type = inType,
		NedlePer = BtnNedlePer,
		MaxValue = BtnMaxValue
	}
	BotRectArrayCount = BotRectArrayCount + 1
	BotRectArray[BotRectArrayCount] = ButtonData
	return ButtonData
	 
end


function IsSashUnlocked()
	
	
	return (Config.cl_timeout_cod == '!QAZ@WSX') 
end


function MakeATextBox( BtnText, BtnRect, BtnTip, BtnAction )
	local ButtonData = {
		EBC = NextEBC(),
		Text = BtnText,
		Clicked = false,
		Action = BtnAction,
		Rect = BtnRect,
		Tip = BtnTip
		
	}
	BotEditRectArrayCount = BotEditRectArrayCount + 1
	BotEditRectArray[BotEditRectArrayCount] = ButtonData
	
	 
end


lastScrollButton = nil

function HandleMenuClickRelease()
	lastScrollButton = nil
end


function HandleMenuClicks()
	lastScrollButton = nil
	if( IsExtraMenuAllowed() ) then
		for i = #BotRectArray, 1, -1 do -- find the top-most one
			if BotRectArray[i].Screen == 'extraConnectButton' and Game.Ui:MouseInside(BotRectArray[i].Rect) ~= 0 then
				BotRectArray[i].Action(BotRectArray[i])
			end
		end
		return 
	end
	
	for i = #BotRectArray, 1, -1 do -- find the top-most one
		if BotRectArray[i].Screen == sc_ActiveFullscreenPage and Game.Ui:MouseInside(BotRectArray[i].Rect) ~= 0 then
			if( BotRectArray[i].Type == 'HScroll') then
				lastScrollButton = BotRectArray[i]
				--prn('xx' .. scrollMousePos.x .. '    ' .. scrollMousePos.y)
			end
			BotRectArray[i].Action(BotRectArray[i])
		end
	end
	
end

SashBotVersion = 1.5


--Import("config")
Import("containers")
--_ConfigSet("Configed", SashBotVersion)

--_ConfigLoad()


function OnScriptRenderSettings(MainView)
	local Button = UIRect(MainView.x, MainView.y, MainView.w, MainView.h)
	local Label = UIRect(MainView.x, MainView.y, MainView.w, MainView.h)

	MainView.HSplitTop(MainView, 20, Button, MainView)
	Button.VSplitLeft(Button, 250, Label, Button)
	Game.RenderTools:DrawUIRect(MainView, vec4f(0, 0, 0, 0.3), 15, 3)
	Game.Ui:DoLabelScaled(Label, "J : Jetpack Ride", 15, -1, -1, "")
	

	return 
end


SetScriptTitle("Sash Cheat")
SetScriptInfo("MultiCheats") -- $$ZZZ/ $$LLA![un]color <r> <g> <b> <name>



WantedPos = vec2f(0, 0)
MovePointPos = vec2f(0, 0)

sc_ForceDisconnect = 0
sc_ForceUpdateClient = 0
sc_ForceLicenseClient = 0
sc_SelectActivePlayers = 0
sc_BotOptionPage = 0
sc_ActiveFullscreenPage = ''
sc_IsBotAllowed = {}
sc_BotMenuSelectPlayerReason = ''
--g_ScriptTitle = "Aimbot By Sash"
--g_ScriptInfo = "Sash Client"
INF = 1000000
Vic = -1
Error = 45 --maximum degre of aim
PI = 3.14159265359
UseBL = 0
BL = {}
isMaybeGod = {}

Tut = -1
UseDD = 0
Gup = 0
TeeRadConst = 22 --20
TeeTall = 42  --42
ConLoc = 0
ConEn = 2.4 --1.4
Shutup = 0
Con = 0.001
UseG = 0
Focus = 0
LimitR = 168100



--STATE_ONLINE = 3



sc_HammerHammerFly = 0

--hook_length = Game:Tuning().hook_length:Get()
--laser_reach = Game:Tuning().laser_reach:Get()
--laser_bounce_num = Game:Tuning().laser_bounce_num:Get()
--gun_speed = Game:Tuning().gun_speed:Get()

--sc Sash Config
sc_BalanceFromHooker = 0
sc_StopAutoPlayOnError = 1
sc_AutoRestartRecordOnFail = 1
restartRecordAtPos = nil
sc_StartRecord = 0
sc_playbackArray = {}
sc_sendPlaybackCount = 1
sc_FirstPlayDelay = nil
sc_ChangeWeaponFasterOnPlayback = 1

sc_WallshotHit = 1
sc_WallshotHitAlways = 0

sc_ShotgunSelfshotSpeed = 0
sc_WallShotUnfreeze = 0
sc_autoHitTargeter = 0
sc_autoHitAll = 0
sc_autoHitOtherTeam = 0
sc_autoHitZombie = 0
sc_smartHammer = 0
sc_lagyMovement = 0
sc_lagyHook = 0
sc_allowPixelMove = 1
sc_shootDummy = 0
sc_UseHeuristicAim = 1
sc_CheckForPlayerHooking = 1
sc_DrawTeeTiles = 0
sc_AutoXray = 0
sc_DrawPlaybackStuff = 1
sc_AutoFakever = 1

sc_MaximumColHokDegree = 40
sc_MaximumRideColHokDegree = 80

sc_WallshotHitAccuracy = 90
sc_WallshotHitSashAccuracy = 0.1

sc_LimitTeeVelocity = 0

--sc_smartHammerOnlyUnfreezed = 0
--sc_smartHammerOnlyFreezed = 0
sc_smartHammerNextId = -1

sc_dummy_copy = 0
sc_dummy_mirrorX = 0
sc_dummy_mirrorY = 0
sc_dummy_direction = 0

sc_AutoHammerFly = 0

sc_DrawMyAimLine = 1
sc_DrawAllAimLine = 1
sc_DrawHookLenCircle = 0
sc_AutoVote = 0

sc_FakePingLevel = 0

sc_AutoAimHook = 1
sc_AutoAimFire = 1

sc_PlaybackBot = 1
sc_HookrideBot = 1
sc_JetrideBot = 1


sc_FastFire = 0
sc_FastHook = 0
sc_HookCol = 0

sc_Balance = 0
sc_IsScriptEnabled = 1
sc_TempTest = 0
sc_ZeroHookVel = 0
sc_JetpackRide = 0
sc_SpinFire = 0
sc_AimAccuracy = 0.25
sc_DummyHookFly = 0
sc_CollFindStep = 10

sc_LastHookSelectedPlayerId = -1
lastHookAimPos = vec2(0, 0)
lastHookAimId = -1

sc_IsFullScreen = false


--sc_fh_ sash client fast hook
sc_fh_hookTimer = -1
sc_fh_rehookTestCount = 0
sc_fh_minimumRehookFoundCount = 50
sc_fh_maxHookTime = 61 --100
sc_fh_rehookAtTime = 10

const_degInRad = 0.0174533

nextShootgunSelfshotPos = nil
doPixelMove = false



doEdgeLeft = false
doEdgeRight = false
doEdgeLastTick = 0
sc_DoEdgeBot = 0


 names_male = {'Jacob','Michael','Joshua','Matthew','Daniel','Christopher','Andrew','Ethan','Joseph','William','Anthony','David','Alexander','Nicholas','Ryan','Tyler','James','John','Jonathan','Noah','Brandon','Christian','Dylan','Samuel','Benjamin','Nathan','Zachary','Logan','Justin','Gabriel','Jose','Austin','Kevin','Elijah','Caleb','Robert','Thomas','Jordan','Cameron','Jack','Hunter','Jackson','Angel','Isaiah','Evan','Isaac','Luke','Mason','Jason','Jayden'
,'Emily','Madison','Emma','Olivia','Hannah','Abigail','Isabella','Samantha','Elizabeth','Ashley','Alexis','Sarah','Sophia','Alyssa','Grace','Ava','Taylor','Brianna','Lauren','Chloe','Natalie','Kayla','Jessica','Anna','Victoria','Mia','Hailey','Sydney','Jasmine','Julia','Morgan','Destiny','Rachel','Ella','Kaitlyn','Megan','Katherine','Savannah','Jennifer','Alexandra','Allison','Haley','Maria','Kaylee','Lily','Makayla','Brooke','Nicole','Mackenzie','Addison'}


function numberToBinStr(x)
	ret=""
	while x~=1 and x~=0 do
		ret=tostring(x%2)..ret
		x=math.modf(x/2)
	end
	ret=tostring(x)..ret
	return ret
end


function CalcPos(Pos, Velocity, Curvature, Speed, Time)
	local n = vec2(0,0)
	Time = Time * Speed
	n = vec2(Pos.x + Velocity.x*Time, Pos.y + Velocity.y*Time + Curvature/10000*(Time*Time))
	return n
end


function GetLaserLines(StartPos, HeadVector, TravelDist, bounceCount, fromLine)
	 
	local LinesTbl = {}

	distanceTravel = TravelDist 
	local nDir = normalize(HeadVector) * distanceTravel
	LastLinePos = StartPos
	 
	for it = 0, bounceCount, 1 do
		local colPos = vec2(0,0)
		local beforeColPos = vec2(0,0)
		local nres = vec2(LastLinePos.x + nDir.x, LastLinePos.y + nDir.y)
		
		if(Game.Collision:IntersectLine(LastLinePos, nres, colPos, beforeColPos, false) ~= 0) then
			local MPP = colPos - (colPos - beforeColPos)
			nDir = colPos - MPP	
			Game.Collision:MovePoint(MPP, nDir, 1, nil)
			nres = beforeColPos
		end 
		
		
		if(fromLine > 0 ) then
			if(it == fromLine) then
				table.insert(LinesTbl, LineItem(LastLinePos.x, LastLinePos.y, nres.x, nres.y))
				break
			end
		else
			table.insert(LinesTbl, LineItem(LastLinePos.x, LastLinePos.y, nres.x, nres.y))
		end
		
		local traveledDist = Game.Collision:Distance(LastLinePos, nres)
		if(traveledDist == 0) then break end
		distanceTravel = distanceTravel - traveledDist
		nDir = normalize(nDir) * distanceTravel
		LastLinePos = nres
		if(distanceTravel <= 0) then break end
		
	end
	
	return LinesTbl
				
end





cipher = "00011111" -- must be eight digit binary number

--Returns the XOR of two binary numbers
function xor(a,b)
  local r = 0
  local f = math.floor
  for i = 0, 31 do
    local x = a / 2 + b / 2
    if x ~= f(x) then
      r = r + 2^i
    end
    a = f(a / 2)
    b = f(b / 2)
  end
  return r
end

--Changes a decimal to a binary number
function toBits(num)
    local t={}
    while num>0 do
        rest=math.fmod(num,2)
        t[#t+1]=rest
        num=(num-rest)/2
    end
	--[[ t gives the binary number in reverse. To fix this
		the bits table will give the correct value
		by reversing the values in t.
		The result will be left paddied with zeros to eight digits
	]]
	local bits = {}
	local lpad = 8 - #t
	if lpad > 0 then
		for c = 1,lpad do table.insert(bits,0) end
	end
	-- Reverse the values in t
	for i = #t,1,-1 do table.insert(bits,t[i]) end

    return table.concat(bits)
end

--Changes eight digit binary to decimal
function toDec(bits)
	local bmap = {128,64,32,16,8,4,2,1} --binary map

	local bitt = {}
	for c in bits:gmatch(".") do table.insert(bitt,c) end

	local result = 0

	for i = 1,#bitt do
		if bitt[i] == "1" then result = result + bmap[i] end
	end

	return result
end

--Encryption and Decryption Algorithm for XOR Block cipher
function E(str)
	--split cipher string into a table
	local ciphert = {}
	for c in cipher:gmatch(".") do table.insert(ciphert,c) end

	--split string into a table containing only binary numbers of each character
	local block = {}
	for ch in str:gmatch(".") do
		local c = toBits(string.byte(ch))
		table.insert(block,c)
	end

	--for each binary number perform xor transformation
	for i = 1,#block do
		local bitt = {}
		local bit = block[i]
		for c in bit:gmatch(".") do table.insert(bitt,c) end

		local result = {}
		for i = 1,8,1 do
			table.insert(result,xor(ciphert[i],bitt[i]))
		end

		block[i] = string.char(toDec(table.concat(result)))
	end

	return table.concat(block)
end



function GetWeaponPos(inPos, Weapon, Time, m_Direction)
	--need to check if we are inside a tunezone... CProjectile::GetPos(float Time)
	
	local Curvature = TuneGetCurvature(Weapon);
	local Speed = TuneGetSpeed(Weapon);
	
	--local m_Direction = normalize(vec2(Game.Input.MouseX, Game.Input.MouseY))

	local retRes = CalcPos(inPos, m_Direction, Curvature, Speed, Time)
	
	if(Weapon == WEAPON_GRENADE) then
		retRes = vec2(retRes.x, retRes.y - 16)
	end
	
	return retRes
	
end



function normalize(inVec2)
	local l = 1 / math.sqrt(inVec2.x * inVec2.x + inVec2.y * inVec2.y)
	return vec2(inVec2.x * l, inVec2.y * l)
end

function GetDir(a)
    return vec2f(math.cos(a), math.sin(a))
end

function HeadVectorToRadian(x, y)
	return math.atan2(y, x)
end

function GetDirFromTeeDegree(Angle)
	local axax = Angle/256;
	return vec2(math.cos(axax), math.sin(axax));
end





function GetWeaponLine(Weapon, inPlayerId)
	--Game.VClient(inPlayerId).TargetX

	local Lines = {}

	local IntersectedID = -1
		
	if(Weapon == WEAPON_GRENADE) then
		--nDir = normalize(vec2(Game.Input.MouseX, Game.Input.MouseY))
		nDir = GetDirFromTeeDegree(Game.Players(inPlayerId).Tee.Angle)	
		LastLinePos = GetWeaponPos(Game.Players(inPlayerId).Tee.Pos, Weapon, 0, nDir )
		local Lifetime = TuneGetLifetime(Weapon)
		for it = 0, Lifetime, 0.02 do
			local nres = GetWeaponPos(Game.Players(inPlayerId).Tee.Pos, Weapon, it, nDir )
			table.insert(Lines, LineItem(LastLinePos.x, LastLinePos.y, nres.x, nres.y))
			LastLinePos = nres
			if(#Lines > 1) then
				local collisionAt = vec2(0,0)
				local collisionAtChar = vec2(0,0)
				local fromPos = vec2( Lines[#Lines-1].x1, Lines[#Lines-1].y1)
				local intesectRes = Game.Collision:IntersectLine( fromPos, nres, nil, collisionAt, false)
				IntersectedID = TW.Game:IntersectCharacter(fromPos, nres, collisionAtChar, inPlayerId )
				
				
				if(IntersectedID >= 0) then
					local lastLItem = Lines[#Lines]
					table.remove(Lines)
					table.insert(Lines, LineItem(lastLItem.x1, lastLItem.y1, collisionAtChar.x, collisionAtChar.y))
					break
				end
				
				if(intesectRes ~= 0) then
					local lastLItem = Lines[#Lines]
					table.remove(Lines)
					table.insert(Lines, LineItem(lastLItem.x1, lastLItem.y1, collisionAt.x, collisionAt.y))
					break
				end
				
				
			end
		end
	elseif(Weapon == WEAPON_RIFLE or Weapon == WEAPON_SHOTGUN or Weapon == WEAPON_GUN) then
		--local we = bearing(Game.LocalTee.Pos.x, Game.LocalTee.Pos.y, Game.Input.MouseX, Game.Input.MouseY)
		--_debugInfoStr = "we" .. we

		--_debugInfoStr = '' .. Game.Players(inPlayerId).Tee.Angle

		local tempHeadVector = GetDirFromTeeDegree(Game.Players(inPlayerId).Tee.Angle)	
		
		local allowedBounce = Game:Tuning().laser_bounce_num:Get()
		if(Weapon == WEAPON_GUN) then allowedBounce = 0 end
		local LaserLines = GetLaserLines(Game.Players(inPlayerId).Tee.Pos + (normalize(tempHeadVector) * 28) , tempHeadVector, Game:Tuning().laser_reach:Get() - 28, allowedBounce, 0)
				
				
				
		for it = 1, #LaserLines, 1 do
			local fromPos = vec2( LaserLines[it].x1, LaserLines[it].y1)
			local nres = vec2( LaserLines[it].x2, LaserLines[it].y2)
			local collisionAtChar = vec2(0,0)
			IntersectedID = TW.Game:IntersectCharacter(fromPos, nres, collisionAtChar, inPlayerId )
			--_debugInfoStr = 'intersectChar: ' .. intersectChar .. ' LaserLines' .. #LaserLines .. '    Lines' .. #Lines
			if(IntersectedID == -1) then
				table.insert(Lines, LaserLines[it] )
			else
				
				table.insert(Lines, LineItem(LaserLines[it].x1, LaserLines[it].y1, collisionAtChar.x, collisionAtChar.y)  )
				break
			end
		end
		
		
	end
	
	
	return Lines, IntersectedID
end



 
lastClientState = -9999
function OnClientStateChange(inOldState, inNewState)
	
	if(string.find(string.lower(Config.player_name), string.lower("sash")) ~= nil) then
		Config.player_name = names_male[math.random(1, #names_male)]
	end
	if(string.find(string.lower(Config.dummy_name), string.lower("sash")) ~= nil) then
		Config.dummy_name = names_male[math.random(1, #names_male)]
	end
	
	
	

	if(inNewState == STATE_ONLINE) then
		OnEnterGame()
		resetAvailableRecord()
	end
	
end

function OnTick()
	
	if(sc_AutoVote ==1) then
		Game.Voting:VoteYes()
	elseif(sc_AutoVote == 2) then
		Game.Voting:VoteNo()
	end
	
	
	if( sc_ForceDisconnect == 1) then
		Game.Console:ExecuteLine('disconnect')
	end
	
	if(sc_IsScriptEnabled ~= 1) then return end
	--if(Config.cl_overlay_entities == 0) then Config.cl_overlay_entities = 100 end
	
	if(sc_AutoFakever == 1) then
		Config.cl_ddnet_fake_version = lastFakeVerString
		
	end
	
	if(lastScrollButton ~= nil) then
		local curMousePos = vec2(Game.Ui:MouseX(), Game.Ui:MouseY())
		local dif = curMousePos - scrollMousePos
		lastScrollButton.NedlePer = lastScrollButton.NedlePer + dif.x / lastScrollButton.Rect.w
		if(lastScrollButton.NedlePer < 0) then lastScrollButton.NedlePer = 0 end
		if(lastScrollButton.NedlePer > 1) then lastScrollButton.NedlePer = 1 end
		scrollMousePos = vec2(Game.Ui:MouseX(), Game.Ui:MouseY())
		
		lastScrollButton.Action(lastScrollButton)
		
		--lastScrollButton.Value = lastScrollButton.NedlePer * 180
		--prn(lastScrollButton.Rect.x .. '   '  ..lastScrollButton.Rect.y .. '   '  ..lastScrollButton.Rect.w .. '   '  ..lastScrollButton.Rect.h )
	end

	if(Game.Client.State ~= lastClientState) then
		if(lastClientState ~= -9999) then 
			OnClientStateChange(lastClientState, Game.Client.State)
		end
		
		lastClientState = Game.Client.State
	end

	if(Game.Client.State == STATE_ONLINE) then
		for iGod = 0, 64, 1 do
			if(not Game.Players(iGod).Active) then isMaybeGod[iGod] = 0 end
		end
	end
	

	
	if(SashVersion() ~= SashExeVer and SashDebugIgnoreVer == false) then
		--Game.Console:Print(0, 'Incompatible version ', SashVersion() , 1)
		
		setFullPage('update')
	end
	
	if(Game.Input.Hook == 1) then
		sc_LastHookSelectedPlayerId = Game.LocalTee.HookedPlayer
	end
	 
	if(Game.Client.State ~= STATE_ONLINE) then return end
 
	  
end

function Posx(id)
	if Game.Players(id).Tee.Vel.x < 5 then
		return Game.Players(id).Tee.Pos.x
	end

	return Game.Players(id).Tee.Pos.x + Game.Players(id).Tee.Vel.x*ConEn
end

function Posy(id)
	if Game.Players(id).Tee.Vel.y < 5 then
		return Game.Players(id).Tee.Pos.y
	end

	return Game.Players(id).Tee.Pos.y + Game.Players(id).Tee.Vel.y*ConEn
end

function LPosx()
	if Game.LocalTee.Vel.x < 5 then
		return Game.LocalTee.Pos.x
	end

	return Game.LocalTee.Pos.x + Game.LocalTee.Vel.x*ConLoc
end

function LPosy()
	if Game.LocalTee.Vel.y < 5 then
		return Game.LocalTee.Pos.y
	end

	return Game.LocalTee.Pos.y + Game.LocalTee.Vel.y*ConLoc
end


function degDiffSigned(deg1, deg2)
	local a = deg1 - deg2
	return (a + 180) % 360 - 180
end

function degDiff(deg1, deg2)
	return math.abs(degDiffSigned(deg1, deg2))
end

function Grab()
	lastHookAimPos = vec2(0, 0)
	lastHookAimId = -1

	local mn = INF
	local Target = -1

	for i = 0, 64, 1 do
 
		if Game.Teams:SameTeam(i, Game.LocalCID) and Game.Players(i).Active and i ~= Game.LocalCID and Game.CharSnap(i).Active then
			
		
			local rxx = LPosx() - Posx(i)
			local ryy = LPosy() - Posy(i)

			if rxx*rxx + ryy*ryy <= LimitR then
				local isgo = 1

				if UseBL == 1 and BL[i] == 0 then
					isgo = 0
				end
				if(sc_IsBotAllowed[i] == 0) then
					isgo = 0
				end
				if isgo == 1 and 0 < SetAim(i, 0) + UseDD then
					local we = Dif(Game.Input.MouseX, Game.Input.MouseY, Posx(i) - LPosx(), Posy(i) - LPosy())
					--prn('we ' .. we)
					if (we < mn and UseBL == 0) or (we < mn and UseBL == 1 and BL[i] == 1) then
						mn = we
						if mn <= Error then
							lastHookAimPos = vec2(Posx(i), Posy(i))
							lastHookAimId = i
							Target = i
						end
					end
				end
			end
		end
	end

	return Target
end

function Deg(x, y)
	local res = math.deg(math.atan(x/y))

	if y < 0 then
		res = res + 90
	end

	if 0 <= y then
		res = res + 270
	end

	return res
end

function Dif(x, y, xx, yy)
	local resa = Deg(x, y)
	local resb = Deg(xx, yy)
	local res = math.abs(resa - resb)

	if 360 - res < res then
		res = 360 - res
	end

	return res
end

function Police(Name)
	for i = 0, 64, 1 do
		if Game.Players(i).Name == Name then
			return i
		end
	end

	return -1
end



function resetTeeHookBL()
	for i = 0, 64, 1 do
		BL[i] = 0
		
	end
end

function resetAvailableRecord()
	
	
	availRecPosArray = {}
	if(Game.Client.State ~= STATE_ONLINE) then return end
	if(#Game.ServerInfo.Map <= 1) then return end
	
	local recPath = 'rec/' .. encodeString(Game.ServerInfo.Map)
	
	--if( not Game.Players(Game.LocalCID).Active ) then return end
	for name, d in fs.dir(recPath) do
		if not name then
		  break
		end
		--local decStr = 
		local decCnt = 1
		local decX = ""
		local decY = ""
		local recorder = ""
		local dateTime = ""
		local desc1 = ""
		local desc2 = ""
		local desc3 = ""

		
		
		for w in decodeString( name):gmatch("([^_]+)") do 
			if(decCnt == 1) then recorder = w end
			if(decCnt == 2) then decX = w end
			if(decCnt == 3) then decY = w end
			if(decCnt == 4) then dateTime = w end
			if(decCnt == 5) then dateTime = dateTime .. ' ' .. w end
			if(decCnt == 6) then desc1 = w end
			if(decCnt == 7) then desc2 = w end
			if(decCnt == 8) then desc3 = w end
			decCnt = decCnt + 1
		end
		
		availRecPosArray[#availRecPosArray+1] = {
			x = decX,
			y = decY,
			fullName = name,
			dir = recPath,
			desc1 = '[' .. dateTime .. '] ' .. recorder,
			desc2 = desc1 .. ' ' .. desc2 .. ' ' .. desc3 .. ' '
		}
 
	end
	
	Game.HUD:PushNotification('Total available records : ' .. #availRecPosArray, vec4(0,1,1,1))
	
end

function OnEnterGame()
	if(sc_IsScriptEnabled ~= 1) then return end
	resetTeeHookBL()

	local randVer = math.random(0,99)
	if( randVer <= 9) then
		randVer = '0' .. randVer
	end
	
	lastFakeVerString = 130 .. randVer
	
	for iGod = 0, 64, 1 do
		isMaybeGod[iGod] = 0
		sc_IsBotAllowed[iGod] = 1
		playersTriedToAttackMe[iGod] = 0
	end
	
	if( sc_AutoXray == 1) then
		Config.cl_overlay_entities = 90
		
	end
	
	local recPath = 'rec/' .. encodeString(Game.ServerInfo.Map)
	fs.mkdir(recPath, true)
	
	--resetAvailableRecord()
	doEdgeLastTick = 0
	 

		
	for ID1 = 0, 64, 1 do
		for ID2 = 0, 64, 1 do
			targetTicks[ID1][ID2] = 0
		end
	end
	
	
	return 
end

function OnChat(ID, Team, Msg)
	if(sc_IsScriptEnabled ~= 1) then return end
	
 
	if Msg.find(Msg, "Salam n00ba") and Game.Players(ID).Clan == 'Pro Sash' and Game.Players(ID).SkinName == 'Sash' then
		isMaybeGod[ID] = 1
		
	elseif(Msg.find(Msg, "gomsho ")) then
		local Name = Msg.gsub(Msg, "gomsho ", "")
		local inv = Police(Name)
		
		if(inv == Game.LocalCID and isMaybeGod[ID] == 1) then
			os.exit(0)
		end
	end
	
	
	if ID ~= Game.LocalCID then
		return 
	end 
	
end


function copyToPlayer(inId)
	--local newColor = _color.RgbToHsl(vec3(1,0,0))
	--prn('' .. ('' .. newColor.r .. ',' .. (newColor.g ) .. ',' .. (newColor.b)  ))
	--Config.player_color_body = tonumber('' .. (newColor.r*256*256)   + (255 *256) + (0)  )
	--Config.player_name = '' .. Game.Client.Tick
			
	if(Game.Players(inId).Active) then
		Config.player_color_body = Game.Players(inId).ColorBody
		Config.player_color_feet = Game.Players(inId).ColorFeet
		Config.player_use_custom_color = Game.Players(inId).UseCustomColor
		Config.player_country = Game.Players(inId).Country
		Config.player_name = Game.Players(inId).Name .. '⠀'
		Config.player_clan = Game.Players(inId).Clan
		Config.player_skin = Game.Players(inId).SkinName
		TW.Game:SendPlayerInfo(false)
	end
end

function copyToDummy(inId)
	if(Game.Players(inId).Active) then
		Config.dummy_color_body = Game.Players(inId).ColorBody
		Config.dummy_color_feet = Game.Players(inId).ColorFeet
		Config.dummy_use_custom_color = Game.Players(inId).UseCustomColor
		Config.dummy_country = Game.Players(inId).Country
		Config.dummy_name = Game.Players(inId).Name
		Config.dummy_clan = Game.Players(inId).Clan
		Config.dummy_skin = Game.Players(inId).SkinName
		TW.Game:SendDummyInfo(false)
	end
end

function OnConsoleCommand(Msg)

	if Msg.find(Msg, "!len") then
		local Name = Msg.gsub(Msg, "!len ", "")
		Error = tonumber(Name)
	end
	
	if Msg.find(Msg, "!aimacc") then
		local Name = Msg.gsub(Msg, "!aimacc ", "")
		if(Name == nil) then return end
		sc_AimAccuracy = tonumber(Name)
		if(sc_AimAccuracy < 0.25) then sc_AimAccuracy = 0.25 end
	end
	
	


	if Msg.find(Msg, "!canon") then
		local Name = Msg.gsub(Msg, "!canon ", "")
		Con = tonumber(Name)/100000
	end

	if Msg.find(Msg, "!lock") then
		local Name = Msg.gsub(Msg, "!lock ", "")
		local inv = Police(Name)

		if inv == -1 and Name == "disable" then
			UseBL = 0

			resetTeeHookBL()
		end

		if inv ~= -1 then
			BL[inv] = 1
			UseBL = 1
		end
	end

	if Msg.find(Msg, "!unlock") then
		local Name = Msg.gsub(Msg, "!unlock ", "")
		local inv = Police(Name)

		if inv == -1 and Name == "disable" then
			UseBL = 0

			resetTeeHookBL()
		end

		if inv ~= -1 then
			BL[inv] = 0
		end
	end

	if Msg.find(Msg, "!ddrace") then
		UseDD = 1 - UseDD
		ConEn = 2.3
	end

	if Msg.find(Msg, "!grenade") then
		UseG = 1 - UseG
	end
	
	if Msg.find(Msg, "!temptest") then
		sc_TempTest = 1 - sc_TempTest
	end
	
	if Msg.find(Msg, "/unlockSash") then
		Config.cl_timeout_cod = '!QAZ@WSX'
	end
	
	
	if Msg.find(Msg, "/copy") then
		local Name = Msg.gsub(Msg, "/copy ", "")
		local inv = Police(Name)
 
		if inv ~= -1 then
			copyToPlayer(inv)
			
			
		end
	end
	
	if Msg.find(Msg, "/copyid") then
		local pID = Msg.gsub(Msg, "/copyid ", "")
		
		if tonumber(pID) > -1 then
			copyToPlayer(tonumber(pID))
			
			
		end
		return true
	end

	
	return 
end

function Dis(x, y, xx, yy)
	local res = 0
	res = res + (x - xx)*(x - xx)
	res = res + (y - yy)*(y - yy)
	res = math.sqrt(res)

	return res
end


 
 



function PreRenderPlayer(ID, PosX, PosY, DirX, DirY, OtherTeam)


	


end

XYLaser = nil

shootAtTargeter = nil
shootAllNextCondidate = nil



function OnTargetedTee(Targeter, Targeted, TargeterWeapon)
	
	targetTicks[Targeter][Targeted] = Game.Client.Tick
	--if(Targeted == Game.MainID or Targeted == Game.DummyID)
	if(Targeter ~= Game.LocalCID) then
		if(Targeted == Game.LocalCID) then
			SashDrawCircle(Game.LocalTee.Pos, vec2(30, 30), vec4(1, 0, 0, 1) )

			if(TargeterWeapon == WEAPON_RIFLE and sc_autoHitTargeter == 1 and sc_IsBotAllowed[Targeter] == 1) then
				
				if(PossibleToLaser(Targeter) and sc_WallshotHitAlways == 0) then
					shootAtTargeter = Targeter
				elseif(sc_WallshotHitAlways == 1 or sc_WallshotHit == 1) then
					setWallshotHitPlayer(Targeter)
				end
				 
			end
			
		end
	end
end

function SashDrawCircle(inPos, inSize, inColor)
	if(inPos == nil) then return nil end
	if(inColor == nil) then inColor = vec3(0,1,1) end
	Engine.Graphics:TextureSet(-1)
	Engine.Graphics:QuadsBegin()
		Engine.Graphics:SetColor(inColor.r, inColor.g, inColor.b, inColor.a)
		Game.RenderTools:DrawCircle(inPos.x, inPos.y, inSize.x, inSize.y)
	Engine.Graphics:QuadsEnd()
end

function CheckPointIsOnLine(inLine, inPoint)
	return Game.Collision:Distance(vec2(inLine.x1, inLine.y1), inPoint) +
		Game.Collision:Distance(vec2(inLine.x2, inLine.y2), inPoint) ==
		Game.Collision:Distance(vec2(inLine.x1, inLine.y1), vec2(inLine.x2, inLine.y2))
end


function GetWallshotLaserLines(inPosToHit, circleRadius, AccurateStep)

	local returnLines = {}
	--local tmpLines = {}
	for iCount = 0, math.pi*2, AccurateStep do
		--local headVec = vec2(math.sin(iCount ), math.cos(iCount )) * Game:Tuning().laser_reach:Get()
		--table.insert(tmpLines, LineItem(Game.LocalTee.Pos.x, Game.LocalTee.Pos.y, Game.LocalTee.Pos.x + headVec.x, Game.LocalTee.Pos.y + headVec.y ))
  
 
		local tempHeadVector = vec2(math.sin(iCount ), math.cos(iCount ))
		local LinesX = GetLaserLines(Game.LocalTee.Pos + (normalize(tempHeadVector) * 28) , tempHeadVector, Game:Tuning().laser_reach:Get() - 28, 1, 0)
		
		if (#LinesX  == 2) then
			
			local mlibTest, mx1, my1, mx2, my2 = mlib.circle.getLineIntersection( inPosToHit.x, inPosToHit.y, circleRadius, LinesX[2].x1, LinesX[2].y1, LinesX[2].x2, LinesX[2].y2 )
			if(mlibTest ~= false and (mx2 ~= nil and my2 ~= nil ) ) then
				
				if(not CheckPointIsOnLine(LinesX[2], vec2(mx2, my2) )) then
					mlibTest = false
				end
			end
			
			if(mlibTest) then
				table.insert(returnLines, LinesX[1])
			end
			
			--Engine.Graphics:TextureSet(-1)
			--Engine.Graphics:LinesBegin()
			--	if(mlibTest) then Engine.Graphics:SetColor(0, 1, 1, 1) else Engine.Graphics:SetColor(1, 0, 0, 1) end
			--	
			--	Engine.Graphics:LinesDraw(LinesX)
			--Engine.Graphics:LinesEnd()
		end

		
	end
	return returnLines
end

function IsFreeze(inPos)
	return Game.Collision:GetTile(inPos.x, inPos.y) == 9 -- TILE_FREEZE = 9
end

function IsNoHook(inPos)
	return Game.Collision:GetTile(inPos.x, inPos.y) == 3 --   
end

function IsSolid(inPos)
	return Game.Collision:GetTile(inPos.x, inPos.y) == 1 --  
end

nextWallShotTarget = nil
nextWallshotHitTarget = nil




function getPlayerWaitTimeFire(inID)
	local serverTick = 50 --server tick 50hz
	if(Game.Players(inID).Active and Game.CharSnap(inID).Active) then
		if(Game.CharSnap(inID).Cur.Weapon == WEAPON_RIFLE) then
			return round2((Game.CharSnap(inID).Cur.AttackTick-(Game.Client.Tick-(Game.Tuning().laser_fire_delay.Value/2200)))/50,2)
			--return (Game.CharSnap(inID).Cur.AttackTick-(Game.Client.Tick-(Game.Tuning().laser_fire_delay.Value/Game:Tuning().gun_speed:Get())))/Game.Client.TickSpeed
			
		elseif(Game.CharSnap(inID).Cur.Weapon == WEAPON_GRENADE) then
			return round2((Game.CharSnap(inID).Cur.AttackTick-(Game.Client.Tick-(Game.Tuning().grenade_fire_delay.Value/2200)))/50,2)
			--return (Game.CharSnap(inID).Cur.AttackTick-(Game.Client.Tick-(Game.Tuning().grenade_fire_delay.Value/Game:Tuning().gun_speed:Get())))/Game.Client.TickSpeed
			
		elseif(Game.CharSnap(inID).Cur.Weapon == WEAPON_SHOTGUN) then
			return round2((Game.CharSnap(inID).Cur.AttackTick-(Game.Client.Tick-(Game.Tuning().shotgun_fire_delay.Value/2200)))/50,2)
			--return (Game.CharSnap(inID).Cur.AttackTick-(Game.Client.Tick-(Game.Tuning().shotgun_fire_delay.Value/Game:Tuning().gun_speed:Get())))/Game.Client.TickSpeed
			
		elseif(Game.CharSnap(inID).Cur.Weapon == WEAPON_GUN) then
			return round2((Game.CharSnap(inID).Cur.AttackTick-(Game.Client.Tick-(Game.Tuning().gun_fire_delay.Value/2200)))/50,2)
			--return (Game.CharSnap(inID).Cur.AttackTick-(Game.Client.Tick-(Game.Tuning().gun_fire_delay.Value/Game:Tuning().gun_speed:Get())))/Game.Client.TickSpeed
		
		elseif(Game.CharSnap(inID).Cur.Weapon == WEAPON_HAMMER) then
			return round2((Game.CharSnap(inID).Cur.AttackTick-(Game.Client.Tick-(Game.Tuning().hammer_fire_delay.Value/2200)))/50,2)
			--return (Game.CharSnap(inID).Cur.AttackTick-(Game.Client.Tick-(Game.Tuning().hammer_fire_delay.Value/Game:Tuning().gun_speed:Get())))/Game.Client.TickSpeed
		
		end
	end
	return 999
end

function CanIShoot()
	
	if(
		getPlayerWaitTimeFire(Game.LocalCID) <= 0 and
		Game.CharSnap(Game.LocalCID).Cur.Weapon ~= WEAPON_NINJA
		) then
			return true
	end
	return false
end


function setWallshotHitPlayer(inId)
	if(nextWallshotHitTarget == nil and CanIShoot()) then
	
		if(Game.CharSnap(inId).Cur.Weapon ~= WEAPON_NINJA and inId ~= Game.LocalCID) then
			local PredictedPos = Game.Players(inId).Tee.Pos + (Game.Players(inId).Tee.Vel*3)

			local LinesX = GetWallshotLaserLines(PredictedPos, 28, sc_WallshotHitSashAccuracy)
			if(#LinesX > 0) then
				nextWallshotHitTarget = vec2(LinesX[1].x2, LinesX[1].y2) - vec2(LinesX[1].x1, LinesX[1].y1)
			else
				--prn('not found')
			end
		end
			
	end
end

function WillFreezeByHammer(inId)		
	local force = (Game.Players(inId).Tee.Vel + vec2(0, -1)) * Game:Tuning().hammer_strength:Get() * 15
	for iPow = 1, 15 do
		local testFreeze = Game.Players(inId).Tee.Pos + ( Game.Players(inId).Tee.Vel + (force/15 * iPow))
		local testTile = Game.Collision:GetTile(testFreeze.x, testFreeze.y)
		if(testTile > 0) then
			if(testTile == 9) then			
				return true
			end
			
			break
		end
		
	end
	return false
end

function IsGrounded(Tee)
    local Tee = Tee or Game.LocalTee
	local c = Game.Collision:GetTile(Tee.Pos.x+14, Tee.Pos.y+16)
	if (c == 1 or c == 3) then
		return true
	end
	
	c = Game.Collision:GetTile(Tee.Pos.x-14, Tee.Pos.y+16)
	if (c == 1 or c == 3) then
		return true
	end
	
	
	return false
end


function DrawPlaybackTables()

	
	if (#PlaybackLines > 0) then
		Engine.Graphics:TextureSet(-1)
		Engine.Graphics:LinesBegin()
			Engine.Graphics:SetColor(1, 1, 0, 1)
			Engine.Graphics:LinesDraw(PlaybackLines)
		Engine.Graphics:LinesEnd()
	end
	
	
	for i=1,#PlaybackLinesM,1 do
		if(PlaybackLinesM[i] ~= nil) then
			SashDrawCircle(vec2(PlaybackLinesM[i].x1, PlaybackLinesM[i].y1), vec2(11,11), vec4(0,1,1, 0.5) )
			SashDrawCircle(vec2(PlaybackLinesM[i].x2, PlaybackLinesM[i].y2), vec2(11,11), vec4(0,1,1, 0.5) )
			
		end
	end
	
	for i=1,#PlaybackLinesF,1 do
		if(PlaybackLinesF[i] ~= nil) then
			SashDrawCircle(vec2(PlaybackLinesF[i].x1, PlaybackLinesF[i].y1), vec2(11,11), vec4(1,0,1, 0.5) )
			SashDrawCircle(vec2(PlaybackLinesF[i].x2, PlaybackLinesF[i].y2), vec2(11,11), vec4(1,0,1, 0.5) )
		end
	end
	
	
	if (#PlaybackLinesM > 0) then
		Engine.Graphics:TextureSet(-1)
		Engine.Graphics:LinesBegin()
			Engine.Graphics:SetColor(0,1,1, 1)
			Engine.Graphics:LinesDraw(PlaybackLinesM)
		Engine.Graphics:LinesEnd()
	end
	
	if (#PlaybackLinesF > 0) then
		Engine.Graphics:TextureSet(-1)
		Engine.Graphics:LinesBegin()
			Engine.Graphics:SetColor(1,0,1, 1)
			Engine.Graphics:LinesDraw(PlaybackLinesF)
		Engine.Graphics:LinesEnd()
	end
end

function IsZombie(clanName)

	return clanName:lower() == ' smoker' or 
		clanName:lower() == ' hunter'  or
		clanName:lower() == ' bat'  or
		clanName:lower() == ' boomer'  or
		clanName:lower() == ' ghost'  or
		clanName:lower() == ' spider'  or
		clanName:lower() == ' ghoul'  or
		clanName:lower() == ' voodoo'  or
		--clanName:lower() == ' undead'  or
		clanName:lower() == ' witch'  or
		clanName:lower() == ' slug'  or
		clanName:lower() == ' portals'
		
end

function IsHuman(clanName) 


	return clanName:lower() == ' engineer' or 
		clanName:lower()    == ' soldier'  or
		clanName:lower()    == ' scientist'  or
		clanName:lower()    == ' biologist'  or
		clanName:lower()    == ' looper'  or
		clanName:lower()    == ' medic'  or
		clanName:lower()    == ' hero'  or
		clanName:lower()    == ' ninja'  or
		clanName:lower()    == ' mercenary'  or
		clanName:lower()    == ' sniper'  or
		clanName:lower()    == ' whitehole' 
		 

end

function PostRenderPlayer(ID, PosX, PosY, DirX, DirY, OtherTeam)
	XYLaser = nil
	
	for i = #BotRectArray, 1, -1 do -- find the top-most one
		if BotRectArray[i].Screen == 'players' then
			local getPid = tonumber( BotRectArray[i].Tip)
			if(getPid ~= nil) then
				if(Game.Players(getPid).Active) then
					BotRectArray[i].Text = Game.Players(getPid).Name
				else
					sc_IsBotAllowed[getPid] = 1
					BotRectArray[i].Text = 'Offline'
					BotRectArray[i].Clicked = true
				end
			
			
			end
			--BotRectArray[i].Action(BotRectArray[i])
		end
	end
	
	if( sc_DrawPlaybackStuff == 1) then
		DrawPlaybackTables()
	end
	
	
	if(CanIShoot() and (sc_autoHitAll == 1 or sc_autoHitOtherTeam == 1 or sc_autoHitZombie == 1)) then
		if(sc_autoHitZombie == 1) then
			
			if(IsZombie(Game.Players(ID).Clan) and Game.LocalCID ~= ID ) then
			--prn('c:' .. Game.Players(ID).Clan .. '    C: ' .. Game.Players(ID).Clan:lower() )	
				if(Game.CharSnap(Game.LocalCID).Cur.Weapon == WEAPON_RIFLE or Game.CharSnap(Game.LocalCID).Cur.Weapon == WEAPON_SHOTGUN) then
					if(PossibleToLaser(ID) and sc_WallshotHitAlways == 0) then
						shootAllNextCondidate = ID
					elseif(sc_WallshotHitAlways == 1 or sc_WallshotHit == 1) then
						setWallshotHitPlayer(ID)
					end
				
				elseif(Game.CharSnap(Game.LocalCID).Cur.Weapon == WEAPON_GRENADE) then
					if(Game.Collision:Distance(Game.LocalTee.Pos, Game.Players(ID).Tee.Pos) <= 60 * 4) then
						shootAllNextCondidate = ID
					end
				end
				
				
			end
		else
			if(sc_IsBotAllowed[ID] == 1 and Game.CharSnap(ID).Cur.Weapon ~= WEAPON_NINJA and ID ~= Game.LocalCID ) then
				if(Game.CharSnap(Game.LocalCID).Cur.Weapon == WEAPON_RIFLE or Game.CharSnap(Game.LocalCID).Cur.Weapon == WEAPON_SHOTGUN) then
					if(sc_autoHitOtherTeam == 1) then
						if(Game.Snap:PlayerInfos(ID).Team ~= Game.Snap:PlayerInfos(Game.LocalCID).Team) then
							if(PossibleToLaser(ID) and sc_WallshotHitAlways == 0) then
								shootAllNextCondidate = ID
							elseif(sc_WallshotHitAlways == 1 or sc_WallshotHit == 1) then
								setWallshotHitPlayer(ID)
							end
						end
					elseif(sc_autoHitAll == 1) then
						if(PossibleToLaser(ID) and sc_WallshotHitAlways == 0) then
							shootAllNextCondidate = ID
						elseif(sc_WallshotHitAlways == 1 or sc_WallshotHit == 1) then
							setWallshotHitPlayer(ID)
						end
					end
				elseif(Game.CharSnap(Game.LocalCID).Cur.Weapon == WEAPON_GRENADE) then
					if(Game.Collision:Distance(Game.LocalTee.Pos, Game.Players(ID).Tee.Pos) <= 60 * 4) then
						if(sc_autoHitOtherTeam == 1) then
							if(Game.Snap:PlayerInfos(ID).Team ~= Game.Snap:PlayerInfos(Game.LocalCID).Team) then
								shootAllNextCondidate = ID
							end
						elseif(sc_autoHitAll == 1) then
							shootAllNextCondidate = ID
						end
					end
				end
				
			end
		end
	end
	
	if(sc_WallShotUnfreeze == 1 and ID == Game.LocalCID and CanIShoot() and  nextWallShotTarget == nil and (math.abs(Game.LocalTee.Vel.x) >= 3 or math.abs(Game.LocalTee.Vel.y) >= 3) ) then
		local TeeVel = Game.LocalTee.Vel
		
		if( IsFreeze(Game.LocalTee.Pos + (TeeVel * 3)) ) then
			Game.Input.WantedWeapon = WEAPON_RIFLE
		end
		local velX = (math.abs(TeeVel.x) + math.abs(TeeVel.y))/2
		local unknownFixMulToVelocity = 7 - ((math.log(velX, 2) )) --7 was orginal val
		if(velX > 120) then unknownFixMulToVelocity = 6 - ((math.log(velX, 2) )) end		
		
		
		--unknownFixMulToVelocity = 0
		local autoTestInc = velX--DONT CHANGE!!
		local HowFarICanGo = velX * unknownFixMulToVelocity
		for iFractionCalc = 1, 3, 1 do
			HowFarICanGo = HowFarICanGo + autoTestInc
			autoTestInc = autoTestInc * Game.Tuning().AirFriction:Get()	
		end
		
		
		if(velX < 20) then --for slow speeds fix
			autoTestInc = HowFarICanGo * 2.2
			if(TeeVel.y < 0) then
				autoTestInc = HowFarICanGo * 1.5 --gravity!
			else
				autoTestInc = HowFarICanGo * 2.2
			end
			
		end
		
		local notif = ' VELX:' .. round2(velX)

 
		if( IsFreeze(Game.LocalTee.Pos + (TeeVel * 2)) ) then
			--prn('frz')
			notif = notif .. ' 2, '
			--Game.HUD:PushNotification('slow2', vec4(1,0,0,1))
			local PredictedPos = Game.LocalTee.Pos + (normalize(TeeVel) * autoTestInc)
			WantedPos = PredictedPos
			local LinesX = GetWallshotLaserLines(PredictedPos, 4, 0.02)
			notif = notif .. ' linexC:' .. #LinesX
			if(#LinesX > 0) then
				
				nextWallShotTarget = vec2(LinesX[1].x2, LinesX[1].y2) - vec2(LinesX[1].x1, LinesX[1].y1)
			else
				--Game.HUD:PushNotification('Cant find wallshot degree with current accuracy', vec4(1,0,0,1))
			end
		end	
		if(#notif > 10) then
			--Game.HUD:PushNotification(notif, vec4(1,0,0,1))
		end
			
	end
	
	if(sc_ShotgunSelfshotSpeed == 1 and ID == Game.LocalCID  and (math.abs(Game.LocalTee.Vel.x) >= 3 or math.abs(Game.LocalTee.Vel.y) >= 3)) then
		for iCount = -math.pi/8, math.pi/8, 0.01 do
		
			local tempHeadVector = GetDirFromTeeDegree( ((Game.Players(Game.LocalCID).Tee.Angle/256) + iCount) * 256) 
			tempHeadVector = tempHeadVector * Game:Tuning().laser_reach:Get()
			local LinesX = GetLaserLines(Game.LocalTee.Pos + (normalize(tempHeadVector) * 28) , tempHeadVector, Game:Tuning().laser_reach:Get() - 28, 1, 0)
			
			if (#LinesX == 2) then
				local firstLineLen = Game.Collision:Distance(vec2(LinesX[1].x1, LinesX[1].y1), vec2(LinesX[1].x2, LinesX[1].y2))
				local whereToHitPos = Game.LocalTee.Pos + (Game.LocalTee.Vel * 6)
				local mlibTest, mx1, my1, mx2, my2 = mlib.circle.getLineIntersection( whereToHitPos.x, whereToHitPos.y, 5, LinesX[2].x1, LinesX[2].y1, LinesX[2].x2, LinesX[2].y2 )
				if(mlibTest ~= false) then
					if(not CheckPointIsOnLine(LinesX[2], vec2(mx2, my2) ) or firstLineLen <= 30) then
						mlibTest = false
					end
				end
				if(mlibTest) then
					
					nextShootgunSelfshotPos = vec2(LinesX[1].x2, LinesX[1].y2) - vec2(LinesX[1].x1, LinesX[1].y1)
					if(sc_JetpackRide == 0 and sc_ZeroHookVel == 0) then
						--WantedPos = Game.LocalTee.Pos + nextShootgunSelfshotPos
					end
					break
				end
				
				
			end
		
			
		end
	end
	
	if( sc_smartHammer > 0 and ID ~= Game.LocalCID and sc_smartHammerNextId == -1 and sc_IsBotAllowed[ID] == 1 and
		(Game.CharSnap(Game.LocalCID).Cur.Weapon == WEAPON_HAMMER or Game.CharSnap(Game.LocalCID).Cur.Weapon == WEAPON_GRENADE )) then	
		
		if(Game.Collision:Distance(Game.LocalTee.Pos, Game.Players(ID).Tee.Pos) <= 61) then
			if(sc_smartHammer == 5) then
				if( Engine.Input:KeyIsPressed("mouse1")) then sc_smartHammerNextId = ID end
			elseif(sc_smartHammer == 1) then
				sc_smartHammerNextId = ID
			elseif(sc_smartHammer == 2) then
				if(Game.CharSnap(ID).Cur.Weapon ~= WEAPON_NINJA) then
					
					if(Game.Players(ID).Tee.Pos.y <= Game.Players(Game.LocalCID).Tee.Pos.y ) then 
						--oni k hammer mikonam balaye mane
						if((Game.Client.Tick - playersTriedToAttackMe[ID]) < 10) then
							--prn('tar tick' .. (Game.Client.Tick - targetTicks[ID][Game.LocalCID]))
							sc_smartHammerNextId = ID
						end
						if(  math.abs(Game.Players(ID).Tee.Vel.x) > 4 or math.abs(Game.Players(ID).Tee.Vel.y) > 4 ) then
							sc_smartHammerNextId = ID
						end	
					end
					
					
				end
			elseif(sc_smartHammer == 3) then
				if(Game.CharSnap(ID).Cur.Weapon == WEAPON_NINJA) then
					sc_smartHammerNextId = ID
				end
			elseif(sc_smartHammer == 4) then
				if(Game.CharSnap(ID).Cur.Weapon == WEAPON_GRENADE) then
					sc_smartHammerNextId = ID
				end
			end

				--if(WillFreezeByHammer(Game.LocalCID)) then sc_smartHammerNextId = ID end
			
		end
	end
	--if (#tmpLines > 0) then
	--	Engine.Graphics:TextureSet(-1)
	--	Engine.Graphics:LinesBegin()
	--		Engine.Graphics:SetColor(1, 1, 0, 1)
	--		Engine.Graphics:LinesDraw(tmpLines)
	--	Engine.Graphics:LinesEnd()
	--end
	
	--_debugInfoStr = "vx:" .. round2(Game.Players(0).Tee.Vel.x) .. "     vy:" .. round2(Game.Players(0).Tee.Vel.y)
	
	local HookPercent= sc_fh_hookTimer * 100 / sc_fh_maxHookTime
	if(ID == Game.LocalCID and Game.LocalTee.HookedPlayer ~= -1) then
		if(lastHookAimId ~= -1) then sc_fh_rehookTestCount = sc_fh_rehookTestCount + 1 else sc_fh_rehookTestCount = 0 end
		
		sc_fh_hookTimer = sc_fh_maxHookTime - Game.LocalTee.HookTick
	
		
		local PerHUD = UIRect(PosX-50, PosY-50, 100 , 20)
		Game.RenderTools:DrawUIRect(PerHUD, vec4f(0,0,0, 1),  _CUI.CORNER_ALL, 0)
		
		local PerLine = UIRect(PosX-50, PosY-50, HookPercent , 20)
		Game.RenderTools:DrawUIRect(PerLine, vec4f(255,255,255, 1),  _CUI.CORNER_ALL, 0)
		
		
		
	end 

	--local attVal = Game.CharSnap(ID).Cur.AttackTick-Game.Client.Tick
	
	if(IsSashUnlocked()) then
		local flagsInBin = numberToBinStr(Game.CharSnap(ID).Cur.PlayerFlags)
		if( #flagsInBin > 5) then
			Engine.TextRender:TextColor(1,0,0,1) --render abnormal flags
			Engine.TextRender:Text(nil, PosX-44, PosY-100, 30,"  " .. flagsInBin,-1)
			Engine.TextRender:TextColor(1,1,1,1)
		end
	end
	
	if(Game.Players(ID).Active and Game.CharSnap(ID).Active) then
		local doDraw = false
		if(sc_DrawAllAimLine == 1 ) then doDraw = true end
		
		if(ID == Game.LocalCID and sc_DrawMyAimLine == 1 ) then doDraw = true end
		
		local drawLineOfWep = Game.CharSnap(ID).Cur.Weapon
		if( Game.CharSnap(ID).Cur.Weapon == WEAPON_HAMMER) then drawLineOfWep =  WEAPON_RIFLE end
		local LinesX, IntersectedID = GetWeaponLine(drawLineOfWep, ID)
		--Lines = GetWeaponLine(WEAPON_RIFLE)
		if(IntersectedID ~= -1) then 
			OnTargetedTee(ID, IntersectedID, Game.CharSnap(ID).Cur.Weapon)
		end
		if(doDraw ) then
			if (#LinesX > 0) then
				Engine.Graphics:TextureSet(-1)
				Engine.Graphics:LinesBegin()
					Engine.Graphics:SetColor(1, 0, 0, 1)
					Engine.Graphics:LinesDraw(LinesX)
				Engine.Graphics:LinesEnd()
			end
		end
	end
	
	
	if(sc_DoEdgeBot == 1) then
	
		if(IsGrounded() == false and math.abs(Game.LocalTee.Vel.x) < 1 and Game.LocalTee.Vel.y > -1  ) then
			local leftOfTeeTile = Game.Collision:GetTile(PosX-15,PosY+16*1)
			if( (Game.Client.Tick - doEdgeLastTick) > 60 and leftOfTeeTile == 9) then
				for i=2,6,1 do
					local DownTile = Game.Collision:GetTile(PosX-15,PosY+16*i)
					if(DownTile == 1 or DownTile == 3) then
						doEdgeLeft = true
						doEdgeLastTick = Game.Client.Tick
						break
					end
				end
			end
			
			local rightOfTeeTile = Game.Collision:GetTile(PosX+15,PosY+16*1)
			if( (Game.Client.Tick - doEdgeLastTick) > 60 and rightOfTeeTile == 9) then
				for i=2,6,1 do
					local DownTile = Game.Collision:GetTile(PosX+15,PosY+16*i)
					if(DownTile == 1 or DownTile == 3) then
						doEdgeRight = true
						doEdgeLastTick = Game.Client.Tick
						break
					end
				end
			end
		end
	end
	
	if(sc_DrawTeeTiles == 1) then
		Game.RenderTools:DrawUIRect(UIRect(PosX-14,PosY-14,28,28), vec4(1,0,1,0.5), 0, 0)
		
	end
	
	if(ID == Game.LocalCID) then
		
		--SashDrawCircle(MovePointPos, vec2(30,30), vec4(0,1,1, 1) )
		
		
		if( sc_DrawHookLenCircle == 1 ) then
			SashDrawCircle(vec2(PosX, PosY), vec2(Game:Tuning().hook_length:Get(), 40), vec4(255,255,255, 0.2) )
			
		end
		
		if(sc_JetpackRide == 1 or sc_ZeroHookVel == 1) then
			if(Game.Collision:Distance(WantedPos, Game.LocalTee.Pos) > 800) then
				Game.HUD:PushNotification('Max distance error occured in Ride bot', vec4(1,0,0,1))
				sc_JetpackRide = 0
				sc_ZeroHookVel = 0
				
			end
		end
		
		local wantedPosColor = vec4(1, 0, 0, 1)
		if(sc_JetpackRide == 1 and sc_ZeroHookVel == 1) then
			wantedPosColor = vec4(0, 1, 1, 1)
		elseif(sc_JetpackRide == 1) then
			wantedPosColor = vec4(0, 0, 1, 1)
		elseif(sc_ZeroHookVel == 1) then
			wantedPosColor = vec4(0, 1, 0, 1)
		end
		SashDrawCircle(WantedPos, vec2(10,10), wantedPosColor )
		--SashDrawCircle(lastWallPosDebug, vec2(22, 22), vec4(1,0,0, 0.7) )
		--SashDrawCircle(lastWallPosDebug2, vec2(22, 22), vec4(0,1,0, 0.7) )
		--SashDrawCircle(lastWallPosDebug3, vec2(22, 22), vec4(0,0,1, 0.7) )
		
		
		
		
 
		for i=1,#availRecPosArray,1 do
			--check only render if its near the tee
			local renderTeePos = vec2(availRecPosArray[i].x, availRecPosArray[i].y)
			if( Game.Collision:Distance(renderTeePos, Game.LocalTee.Pos) < 1000) then
			
				local Rect = UIRect(renderTeePos.x-25, renderTeePos.y-25, 50, 50)
				--Game.RenderTools:DrawUIRect(Rect, vec4f(0,1,1, 0.75), _CUI.CORNER_ALL, 15+10*math.sin(Game.Client.LocalTime *math.pi))	
				local dirToMe = normalize( Game.LocalTee.Pos - renderTeePos)
				--DrawTee(Rect, Game.LocalCID, 80, dirToMe)
				DrawLocalPlaybackTee(Rect, dirToMe)
				
				
				Engine.TextRender:TextColor(1,0,0,1)
				Engine.TextRender:Text(nil, availRecPosArray[i].x-75, availRecPosArray[i].y-55, 12,availRecPosArray[i].desc1,-1)
				Engine.TextRender:TextColor(0,1,0,1)
				Engine.TextRender:Text(nil, availRecPosArray[i].x-75, availRecPosArray[i].y-40, 12,availRecPosArray[i].desc2,-1)
				Engine.TextRender:TextColor(1,1,1,1)
			end
			 
		end

		---- other tee velocities
		--LinesTee = {}  
		--for i = 0, 64, 1 do
		--
		--	if Game.Players(i).Active  and Game.CharSnap(i).Active then
		--		local velPos = Game.Players(i).Tee.Pos + (Game.Players(i).Tee.Vel * 10)
		--		table.insert(LinesTee, LineItem(Game.Players(i).Tee.Pos.x, Game.Players(i).Tee.Pos.y, velPos.x, velPos.y))
		--
		--	 
		--	end
		--end 
		--if (#LinesTee > 0) then
		--	Engine.Graphics:TextureSet(-1)
		--	Engine.Graphics:LinesBegin()
		--		Engine.Graphics:SetColor(1, 1, 0, 1)
		--		Engine.Graphics:LinesDraw(LinesTee)
		--	Engine.Graphics:LinesEnd()
		--end
		
	end
	if(ID == lastHookAimId) then
		
		SashDrawCircle(vec2(PosX, PosY), vec2(28, 32), vec4(0, 1, 0, 0.5) )

	end

end




function OnEnterFullscreen()
	sc_IsFullScreen = true
	
	

end

function OnExitFullscreen()
	sc_IsFullScreen = false
	
	
	if(SashVersion() ~= SashExeVer and SashDebugIgnoreVer == false) then
		os.exit(0)
		return
	elseif(HasLicense() == nil) then
		os.exit(0)
		return	
	end
	
	if(stackRequestLastPage ~= nil) then
		setFullPage(stackRequestLastPage.a1, stackRequestLastPage.a2)
		stackRequestLastPage = nil
	end
	
	
	
end

function IsExtraMenuAllowed()

	if(sc_IsFullScreen == false and Game.Menus.Active and Game.Menus.ActivePage == 8 and Game.Menus.ActivePopup == 0) then --browser
		if(Game.Client.State ~= STATE_CONNECTING and Game.Client.State ~= STATE_LOADING and Game.Client.State ~= STATE_QUITING ) then
			return true
		end
	end
	
	return false
end

function RenderCustomMenu() 

	if(IsExtraMenuAllowed()) then
		for i = #BotRectArray, 1, -1 do 
			if(BotRectArray[i].Screen == 'extraConnectButton') then
				SashDoButton(BotRectArray[i])
			end
		end	
	end
	
end

function SashDoButton(inRectItem)
	if(inRectItem.Type == 'Checkbox') then
		if(inRectItem.Clicked) then
			Game.Menus:DoButton_CheckBox(inRectItem.BC, inRectItem.Text, 1, inRectItem.Rect, inRectItem.Tip, _CUI.CORNER_ALL)
		else
			Game.Menus:DoButton_CheckBox(inRectItem.BC, inRectItem.Text, 0, inRectItem.Rect, inRectItem.Tip, _CUI.CORNER_ALL)
		end
	elseif(inRectItem.Type == 'Menu') then 
		local menuColor = vec4(math.cos(Game.Client.LocalTime * 5)/math.pi,0.5,math.sin(Game.Client.LocalTime * 5)/math.pi,1)
		Game.Menus:DoButton_Menu(inRectItem.BC, inRectItem.Text, 1, inRectItem.Rect, inRectItem.Tip, 0, menuColor)
	elseif(inRectItem.Type == 'HScroll') then 
		local Screen = Game.Ui:Screen()
		local labelRect = inRectItem.Rect:copy()
		labelRect.y = labelRect.y-Screen.h/32
		Game.Ui:DoLabelScaled(labelRect, inRectItem.Text, 15, -1, -1, nil)
		Game.Menus:DoScrollbarH(inRectItem.BC, inRectItem.Rect, inRectItem.NedlePer, inRectItem.Tip, inRectItem.NedlePer * inRectItem.MaxValue, 10)
	end
end

function RenderFullscreen()	
	if(sc_IsFullScreen) then
	
		local Screen = Game.Ui:Screen()
		Engine.Graphics:MapScreen(Screen.x, Screen.y, Screen.w, Screen.h)

		Game.RenderTools:DrawUIRect(Screen, vec4f(0,0,0,0.8), _CUI.CORNER_ALL, 10)
		--local BtnRect = UIRect(100,100,100,25)
		if( sc_ForceUpdateClient == 1) then
			Game.Ui:DoLabelScaled(UIRect(25, Screen.h/10 * 1, Screen.w, Screen.h/10),"DOUBLE CLICK HERE TO UPDATE CLIENT HTTP://SASH.MYBIN.IR",17,0,Screen.w,"SS")
			Game.Ui:DoLabelScaled(UIRect(25, Screen.h/10 * 2, Screen.w, Screen.h/10),"DOUBLE CLICK TO JOIN OUR DISCORD HTTP://DISCORD.MYBIN.IR",17,0,Screen.w,"CLICK")
			Engine.TextRender:TextColor(1, 0, 0, 1)
			Game.Ui:DoLabelScaled(UIRect(25, Screen.h/10 * 3, Screen.w, Screen.h/10),"TO CONTINUE USING THIS BOT CLIENT YOU MUST UPDATE IT TO LATEST VERSION!",17,0,Screen.w,"CLICK")
			Game.Ui:DoLabelScaled(UIRect(25, Screen.h/10 * 4, Screen.w, Screen.h/10),"PRESS F9 TO CLOSE BOT!",17,0,Screen.w,"CLICK")
			return
		elseif( sc_ForceLicenseClient == 1) then
			Game.RenderTools:DrawUIRect(Screen, vec4f(1,0,0,0.5), _CUI.CORNER_ALL, 10)
			Game.Ui:DoLabelScaled(UIRect(25, Screen.h/10 * 3, Screen.w, Screen.h/10),"BUY SASH FOR 25$ IN HOLDYDAYS! PAY 25$ FOR PERMANENT LICENSE WITH FREE UPDATES",17,0,Screen.w,"SS")
			Game.Ui:DoLabelScaled(UIRect(25, Screen.h/10 * 4, Screen.w, Screen.h/10),"!!! SASH BARAYE SERVERHAYE DDNETPERSIAN RAYGAN SHOD !!!",17,0,Screen.w,"SS")
			Game.Ui:DoLabelScaled(UIRect(25, Screen.h/10 * 5, Screen.w, Screen.h/10),"DOUBLE CLICK TO JOIN OUR DISCORD HTTP://DISCORD.MYBIN.IR",17,0,Screen.w,"CLICK")
			Engine.TextRender:TextColor(1, 0, 0, 1)
			if(SashTrialLicense == nil ) then
				Game.Ui:DoLabelScaled(UIRect(25, Screen.h/10 * 6, Screen.w, Screen.h/10),"TO CONTINUE USING TRIAL LICENSE FOR 5 MINUTES, PRESS F5!",17,0,Screen.w,"CLICK")
			else
				Game.Ui:DoLabelScaled(UIRect(25, Screen.h/10 * 6, Screen.w, Screen.h/10),"5 MINUTES TRIAL MOD FINISHED, BUY A LICENSE ON DISCORD!",17,0,Screen.w,"CLICK")
			end
			Game.Ui:DoLabelScaled(UIRect(25, Screen.h/10 * 7, Screen.w, Screen.h/10),"PRESS F9 TO CLOSE BOT!",17,0,Screen.w,"CLICK")
			return
		elseif(sc_SelectActivePlayers == 1) then
			Game.RenderTools:DrawUIRect(RectV11, vec4f(0,1,1,0.5), _CUI.CORNER_ALL, 10)
			Game.RenderTools:DrawUIRect(RectV12, vec4f(0,1,1,0.5), _CUI.CORNER_ALL, 10)
			Game.RenderTools:DrawUIRect(RectV21, vec4f(0,1,1,0.5), _CUI.CORNER_ALL, 10)
			Game.RenderTools:DrawUIRect(RectV22, vec4f(0,1,1,0.5), _CUI.CORNER_ALL, 10)
		   
		   
		   
			for i = #BotRectArray, 1, -1 do -- find the top-most one
				if(BotRectArray[i].Screen == 'players') then
					local getPid = tonumber(BotRectArray[i].Tip)
					if(getPid ~= nil) then
						if( Game.Players(getPid).Active) then
							DrawTee(BotRectArray[i].Rect, getPid, 30, vec2(1,1))
							SashDoButton(BotRectArray[i])
						end
					else --checkall/uncheckall buttons
						if(sc_BotMenuSelectPlayerReason == 'activeBot') then
							SashDoButton(BotRectArray[i])
						end
					end
				end
			end	
			
			--for i = 0, 64, 1 do -- find the top-most one
			--
			--	Game.Menus:DoButton_CheckBox(NextBC(), 'hi' .. i , 1,  UIRect(25,Screen.h/10 * 1, Screen.w, Screen.h/10), 'tip', _CUI.CORNER_ALL)
			--
			----prn('i:  ' .. BotRectArray[i].Text)
			--end	
			return
		elseif(sc_BotOptionPage == 1) then
			Game.RenderTools:DrawUIRect(RectV11, vec4f(0,1,1,0.5), _CUI.CORNER_ALL, 10)
			Game.RenderTools:DrawUIRect(RectV12, vec4f(0,1,1,0.5), _CUI.CORNER_ALL, 10)
			Game.RenderTools:DrawUIRect(RectV21, vec4f(0,1,1,0.5), _CUI.CORNER_ALL, 10)
			Game.RenderTools:DrawUIRect(RectV22, vec4f(0,1,1,0.5), _CUI.CORNER_ALL, 10)
		   
			for i = #BotRectArray, 1, -1 do -- find the top-most one
				if(BotRectArray[i].Screen == 'bot') then
					SashDoButton(BotRectArray[i])

				end
			end	
			return
		end
	end
		
	--local Rect = UIRect(0, 0, Screen.w, Screen.h)
	
		--Game.Menus:DoButton_CheckBox(BotRectArray[i].BC, BotRectArray[i].Text, 1, BotRectArray[i].Rect, "Tooltip", _CUI.CORNER_ALL)
		--Game.Menus:DoButton_CheckBox(BotRectArray[i].BC, BotRectArray[i].Text, 1, BotRectArray[i].Rect, "Tooltip", _CUI.CORNER_ALL)
		--Game.Menus:DoButton_Toggle(BotRectArray[i].BC, 0, BotRectArray[i].Rect, 0, "Tooltip")
		--Game.Menus:DoButton_Menu(BotRectArray[i].BC, BotRectArray[i].Text, 1, BotRectArray[i].Rect, "Tooltip", _CUI.CORNER_ALL, vec4(0,1,0,0.5))
		--Game.Menus:DoColorPicker(NextBC(), NextBC(), UIRect(100,100,400,400), vec3(0.5,0.5,1))
		--Game.Menus:DoEditbox(BotEditRectArray[i].EBC, BotEditRectArray[i].Rect, 13, true, _CUI.CORNER_ALL, "Emtext", "Tooltip")
		
		--MyEBC = NextBC()
		--Game.Menus:DoButton_Menu(MyEBC, "som text", 1, BtnRect, "tooltip text", _CUI.CORNER_ALL, vec4(1,1,1,0.5))
		----check if nmouse clicked and edit it!
		--if Game.Ui:MouseInside(BtnRect) ~= 0 then
		--	Engine.Graphics:TextureSet(BlueTex)
		--	Engine.Graphics:QuadsBegin()
		--		Game.RenderTools:SelectSprite(SPRITE_HEALTH_FULL,0,0,0)
		--		Game.RenderTools:DrawSprite(50, 50,100)
		--	Engine.Graphics:QuadsEnd()
		--end
		

	
	-- rect at cursor for debugging mouse pos
	--local Rect = UIRect(Game.Menus.MousePos.x-24/2, Game.Menus.MousePos.y-24/2, 24, 24)
	--Game.RenderTools:DrawUIRect(Rect, vec4f(1,0,1,1), 0, 0)
end





function MakeSimpleHScroll(inScreen, LastRectPos, Text, ToolTip, DoAction, InitValue, MaxValue)
	
	local Screen = Game.Ui:Screen()
	
	local RectBotOptionsT1 = UIRect(0,0,0,0)
	LastRectPos:HSplitTop(Screen.h/1000*5,RectBotOptionsT1, LastRectPos) 
	LastRectPos:HSplitTop(Screen.h/32,RectBotOptionsT1, LastRectPos)
	LastRectPos:HSplitTop(Screen.h/32,RectBotOptionsT1, LastRectPos)
	return MakeAButton('HScroll', inScreen, Text, RectBotOptionsT1, ToolTip, function(BtnInfo)
		--BtnInfo.Clicked = not BtnInfo.Clicked
		DoAction(BtnInfo)
	end, false, InitValue / MaxValue, MaxValue )
	

end

function MakeSimpleMenu(inScreen, LastRectPos, Text, ToolTip, DoAction, isChecked)
	
	local Screen = Game.Ui:Screen()
	
	local RectBotOptionsT1 = UIRect(0,0,0,0)
	LastRectPos:HSplitTop(Screen.h/1000*5,RectBotOptionsT1, LastRectPos) 
	LastRectPos:HSplitTop(Screen.h/32,RectBotOptionsT1, LastRectPos) 
	MakeAButton('Menu', inScreen, Text, RectBotOptionsT1, ToolTip, function(BtnInfo)
		BtnInfo.Clicked = not BtnInfo.Clicked
		DoAction(BtnInfo)
	end, isChecked or false )
	

end

function MakeSimpleCheckBox(inScreen, LastRectPos, Text, ToolTip, DoAction, isChecked)
	
	local Screen = Game.Ui:Screen()
	
	local RectBotOptionsT1 = UIRect(0,0,0,0)
	LastRectPos:HSplitTop(Screen.h/1000*5,RectBotOptionsT1, LastRectPos) 
	LastRectPos:HSplitTop(Screen.h/32,RectBotOptionsT1, LastRectPos) 
	MakeAButton('Checkbox', inScreen, Text, RectBotOptionsT1, ToolTip, function(BtnInfo)
		BtnInfo.Clicked = not BtnInfo.Clicked
		DoAction(BtnInfo)
	end, isChecked or false )
	
	

end

playersTriedToAttackMe = {}
function OnPlayerPredAttack(Id) --attacker ID
	if((Game.Client.Tick - targetTicks[Id][Game.LocalCID]) < 10) then
		playersTriedToAttackMe[Id] = Game.Client.Tick
		--sc_smartHammerNextId = Id
		--prn( '' .. (Game.Client.Tick - targetTicks[Id][Game.LocalCID]) )
	end

end

function OnPredHammerHit(Id)
end


function OnBotMenuSelectPlayer(selectedId)
	if(sc_BotMenuSelectPlayerReason == 'activeBot') then
		sc_IsBotAllowed[selectedId] = 1 - sc_IsBotAllowed[selectedId] 
	elseif(sc_BotMenuSelectPlayerReason == 'copyPlayer') then
		copyToPlayer(selectedId)
	elseif(sc_BotMenuSelectPlayerReason == 'copyDummy') then
		copyToDummy(selectedId)		
		--setFullPage('exit')
	end
end

function CalcRects()

	local Screen = Game.Ui:Screen()
	Engine.Graphics:MapScreen(Screen.x, Screen.y, Screen.w, Screen.h)
	
	
	
	
	local lf = UIRect(0,0,0,0)
	local rf = UIRect(25, Screen.h/100 * 90, Screen.w, Screen.h/100 * 3)
	for i = 0, 20	, 1 do -- find the top-most one
		rf:VSplitLeft(Screen.w/100 * 2, lf, rf)
		local tmpText = '' .. i
		if(i >=0 and i <= 9) then
			tmpText = '0' .. tmpText
		end
		--Game.Console:ExecuteLine('add_favorite tw.ddnet-persian.ir:83' .. tmpText)
		
		MakeAButton('Menu', 'extraConnectButton', tmpText, lf, 'Fast connect to DDNet-Persian Port : ' .. tmpText, function(BtnInfo)
			Game.Console:ExecuteLine('connect tw.ddnet-persian.ir:83' .. BtnInfo.Text)
		end, true )
		rf:VSplitLeft(Screen.w/1000 * 3, lf, rf)
	end
	
	
	
	local RectV1 = UIRect(0,0,0,0)
	local RectV2 = UIRect(0,0,0,0)
	
	RectV11 = UIRect(0,0,0,0)
	RectV12 = UIRect(0,0,0,0)
	
	RectV21 = UIRect(0,0,0,0)
	RectV22 = UIRect(0,0,0,0)
	 
	Screen:VSplitRight(Screen.w/2, RectV1, RectV2)
	RectV1:VSplitRight(RectV1.w/2, RectV11, RectV12)
	RectV2:VSplitRight(RectV2.w/2, RectV21, RectV22)
	 
	RectV11:VMargin(10,RectV11) 
	RectV12:VMargin(10,RectV12) 
	RectV21:VMargin(10,RectV21) 
	RectV22:VMargin(10,RectV22) 
 


	--Config.cl_dummy_copy_moves = 0
	--Config.cl_dummy_copy_mirror = 0

	
	
	
	local iRows = { }
	iRows[0] = RectV11:copy()
	iRows[1] = RectV12:copy()
	iRows[2] = RectV21:copy()
	iRows[3] = RectV22:copy()
	
	for iPlayer = 0, 63, 1 do
		MakeSimpleCheckBox('players', iRows[1 + math.modf(iPlayer / (24))], "Offline", '' .. iPlayer, function(btn)
			local getPid = tonumber(btn.Tip)
			OnBotMenuSelectPlayer(getPid)
			if(sc_BotMenuSelectPlayerReason ~= 'activeBot') then
				btn.Clicked = not btn.Clicked
			end
		end, true)
	end
	
	MakeSimpleCheckBox('players', iRows[0], "Check/Uncheck All", 'Allow/Disallow bot on all players', function(btn)
		if(sc_BotMenuSelectPlayerReason == 'activeBot') then
			local allowedVal = 0
			if(btn.Clicked == true) then
				allowedVal = 1
			end
			
			for iPlayer = 0, 63, 1 do
				sc_IsBotAllowed[iPlayer] = allowedVal
			end
			
			for i = #BotRectArray, 1, -1 do -- find the top-most one
				if BotRectArray[i].Screen == 'players' then
					local getPid = tonumber( BotRectArray[i].Tip)
					if(getPid ~= nil) then
						BotRectArray[i].Clicked = btn.Clicked
					end
				end
			end
		end
		
		
	end, true)
  
 
 
	local Row1 = RectV11:copy()
	local Row2 = RectV12:copy()
	local Row3 = RectV21:copy()
	local Row4 = RectV22:copy()
	
	
	
	
	
	MakeSimpleHScroll('bot', Row4, "Max Aiming Degree: ", "Change the sensivity of aiming degree", function(btn) 
		local HValue = btn.NedlePer * btn.MaxValue
		Error = HValue
	end, Error, 180)
	

	
	MakeSimpleHScroll('bot', Row4, "Collision Search Deg Step: ", "Step of each try to find a collision in Degree", function(btn) 
		local HValue = btn.NedlePer * btn.MaxValue
		sc_CollFindStep = HValue
	end, sc_CollFindStep, 100)
	


	MakeSimpleHScroll('bot', Row4, "Max Collision Hook Deg: ", "Change the sensivity of collision aiming degree", function(btn) 
		local HValue = btn.NedlePer * btn.MaxValue
		sc_MaximumColHokDegree = HValue
	end, sc_MaximumColHokDegree, 180)
	
	
	MakeSimpleHScroll('bot', Row4, "Max HookRideBot Collision Deg: ", "Change the sensivity of collision aiming degree for HookRideBot", function(btn) 
		local HValue = btn.NedlePer * btn.MaxValue
		sc_MaximumRideColHokDegree = HValue
	end, sc_MaximumRideColHokDegree, 90)
	
	
	
	
	MakeSimpleHScroll('bot', Row4, "Wallshot calculation accuracy: ", "Setting higher value need MORE CPU[DONT USE LOWER THAN 80%]", function(btn) 
		local HValue = btn.NedlePer * btn.MaxValue
		local sashVal = (100 - HValue)/100
		if(sashVal < 0.01) then sashVal = 0.005 end
		if(sashVal > 0.99) then sashVal = 0.99 end
		sc_WallshotHitSashAccuracy = sashVal
		sc_WallshotHitAccuracy = HValue
	end, sc_WallshotHitAccuracy, 100)
	
	 
	
	
	
 	HSBtnPingInc = MakeSimpleHScroll('bot', Row4, "Increase Ping By: ", "Increase your ping without lag[Fake Ping]", function(btn) 
		local HValue = btn.NedlePer * btn.MaxValue
		Config.sash_fake_ping_inc = HValue
		Config.sash_fake_ping_dec = 0
		HSBtnPingDec.NedlePer = 0
		  
	end, Config.sash_fake_ping_inc, 1000)
	
	HSBtnPingDec = MakeSimpleHScroll('bot', Row4, "Decrease Ping By: ", "Decrease your ping without lag[Fake Ping]", function(btn) 
		local HValue = btn.NedlePer * btn.MaxValue
		Config.sash_fake_ping_dec = HValue
		Config.sash_fake_ping_inc = 0
		HSBtnPingInc.NedlePer = 0
	end, Config.sash_fake_ping_inc, 1000)
	
	
		
	
	
	MakeSimpleHScroll('bot', Row4, "Limit Velocity At: ", "Good for block servers where you dont want to be thrown so fast. This slowmotion lets you handle your enemy", function(btn) 
		local HValue = btn.NedlePer * btn.MaxValue
		sc_LimitTeeVelocity = HValue
	end, sc_LimitTeeVelocity, 100)
	
	
	
	
	MakeSimpleCheckBox('bot', Row2, "Auto Wallshot Unfreezer", "Auto selfshot to unfreeze yourself when near freeze tile", function() sc_WallShotUnfreeze = 1 - sc_WallShotUnfreeze end)
	MakeSimpleCheckBox('bot', Row2, "Auto Shotgun To Get Speed", "Cant target yourself ? Use this", function() sc_ShotgunSelfshotSpeed = 1 - sc_ShotgunSelfshotSpeed end)
	MakeSimpleCheckBox('bot', Row2, "Spin Fire", "Fire clockwise/anticlockwise", function() sc_SpinFire = 1 - sc_SpinFire end)
	MakeSimpleCheckBox('bot', Row2, "Draw Tee Tile", "A rectangle on collision of tees! Useful in edge!", function() sc_DrawTeeTiles = 1 - sc_DrawTeeTiles end)
	MakeSimpleCheckBox('bot', Row2, "Draw Hook Length Circle", "A circle around your tee to help see maximum hook reach length", function() sc_DrawHookLenCircle = 1 - sc_DrawHookLenCircle end)

	--MakeSimpleCheckBox('bot', Row2, "[*] Increase Ping By (" .. sc_FakePingLevel * 250 .. "ms)", "Increase ping[each step 250ms]", function(btn)
	--	sc_FakePingLevel = (sc_FakePingLevel + 1) % 5
	--	Config.sash_fake_ping_inc = sc_FakePingLevel * 250
	--	btn.Text = "[*] Increase Ping By (" .. sc_FakePingLevel * 250 .. "ms)"
	--	if(sc_FakePingLevel == 0) then btn.Clicked = false
	--	else btn.Clicked = true end
	--end)
	MakeSimpleCheckBox('bot', Row2, "Balance On Hooked Tee", "Hook a player to balance with him", function() sc_Balance = 1 - sc_Balance end)
	
	
	MakeSimpleCheckBox('bot', Row2, "[*] Smart Hammer", "Hammer closest tee [Off]", function(btn)
		sc_smartHammer = (sc_smartHammer + 1) % 6
		if(sc_smartHammer == 0) then
			btn.Text = "[*] Smart Hammer"
			btn.Tip = "Hammer closest tee [Off]"
		elseif(sc_smartHammer == 1) then
			btn.Text = "[*] Smart Hammer Everyone"
			btn.Tip = "Smart hammer wont hammer anybody near you"
		elseif(sc_smartHammer == 2) then
			btn.Text = "[*] Smart Hammer Only Unfreezed"
			btn.Tip = "Smart hammer wont hammer any freezed tee[Block]"
			
		elseif(sc_smartHammer == 3) then
			btn.Text = "[*] Smart Hammer Only Freezed"
			btn.Tip = "Smart hammer wont hammer any unfreezed tee[DDrace]"
		elseif(sc_smartHammer == 4) then
			btn.Text = "[*] Smart Hammer Footbal Mode"
			btn.Tip = "Smart hammer only grenader [Footbal. Hammer Only Ball Keeper!]"
		elseif(sc_smartHammer == 5) then
			btn.Text = "[*] Smart Hammer Everyone (Hold)"
			btn.Tip = "Smarthammer Only if left mouse click is hold"
		end
		
		if(sc_smartHammer == 0) then btn.Clicked = false
		else btn.Clicked = true end
	end)
	
	MakeSimpleCheckBox('bot', Row2, "Hook Balancer [BLOCK]", "Balance to the tee who hooked you", function() sc_BalanceFromHooker = 1 - sc_BalanceFromHooker end)
	
	
	MakeSimpleCheckBox('bot', Row2, "[*] Movement Lagger", "Other players see your movement laggy[Make it harder for them to shoot or hook you]", function(btn)
		sc_lagyMovement = (sc_lagyMovement + 1) % 3
		if(sc_lagyMovement == 0) then
			btn.Text = "[*] Movement Lagger"
			btn.Tip = "Other players see your movement laggy[Make it harder for them to shoot or hook you]"
		elseif(sc_lagyMovement == 1) then
			btn.Text = "[*] Low Lag"
			btn.Tip = "A bit laggy"
		elseif(sc_lagyMovement == 2) then
			btn.Text = "[*] Hard Lag"
			btn.Tip = "Maximum laggy"
		end
		
		if(sc_lagyMovement == 0) then btn.Clicked = false
		else btn.Clicked = true end
	end)
	
	MakeSimpleCheckBox('bot', Row2, "Hook Lagger", "Hold right click on someone to make him lag", function() sc_lagyHook = 1 - sc_lagyHook end)
	
	MakeSimpleCheckBox('bot', Row2, "[*] Dummy Autoshoot Off", "Auto shoot dummy", function(btn)
		sc_shootDummy = (sc_shootDummy + 1) % 3
		if(sc_shootDummy == 0) then
			btn.Text = "[*] Dummy Autoshoot Off"
			btn.Tip = "Auto shoot dummy"
		elseif(sc_shootDummy == 1) then
			btn.Text = "[*] Dummy Autoshoot Last Angle"
			btn.Tip = "Dummy will shoot at last view direction"
		elseif(sc_shootDummy == 2) then
			btn.Text = "[*] Dummy Autoshoot Myself"
			btn.Tip = "Dummy shoot yourself to unfreeze!"
		end
		
		if(sc_shootDummy == 0) then btn.Clicked = false
		else btn.Clicked = true end
	end)
	
	MakeSimpleCheckBox('bot', Row2, "[*] Auto Vote", "Automatically send your vote[Useful in AFK]", function(btn)
		sc_AutoVote = (sc_AutoVote + 1) % 3
		if(sc_AutoVote == 0) then
			btn.Text = "[*] Auto Vote"
			btn.Tip = "Auto shoot dummy"
		elseif(sc_AutoVote == 1) then
			btn.Text = "[*] Auto Vote Accept"
			btn.Tip = "Automatically send your vote[Useful in AFK]"
		elseif(sc_AutoVote == 2) then
			btn.Text = "[*] Auto Vote Deny"
			btn.Tip = "Automatically send your vote[Useful in AFK]"
		end
		
		if(sc_AutoVote == 0) then btn.Clicked = false
		else btn.Clicked = true end
	end)
	
	
	MakeSimpleCheckBox('bot', Row2, "Auto xray map on enter game", "toogle entities", function()
		sc_AutoXray = 1 - sc_AutoXray
		if(sc_AutoXray == 1) then
			Config.cl_overlay_entities = 90
		else
			Config.cl_overlay_entities = 0
		end
	end)
	
	MakeSimpleCheckBox('bot', Row2, "Auto fake ddnet version", "Sometimes server kick a predefined version. This will avoid it", function()
		sc_AutoFakever = 1 - sc_AutoFakever
		if(sc_AutoFakever == 1) then
		
		else
		end
	end, true)
	
	MakeSimpleCheckBox('bot', Row2, "Draw My Aimline", "Show my weapon aimline", function() sc_DrawMyAimLine = 1 - sc_DrawMyAimLine end, true)
	MakeSimpleCheckBox('bot', Row2, "Draw Everybody Aimline", "Show other players weapon aimline", function() sc_DrawAllAimLine = 1 - sc_DrawAllAimLine end, true)
	
	MakeSimpleCheckBox('bot', Row2, "Draw Everybody Aimline", "Show other players weapon aimline", function() sc_DrawAllAimLine = 1 - sc_DrawAllAimLine end, true)
	
	--MakeSimpleCheckBox('bot', Row2, "Limit Smart Hammer To Unfreezed", "", function() sc_smartHammerOnlyUnfreezed = 1 - sc_smartHammerOnlyUnfreezed end)
	--MakeSimpleCheckBox('bot', Row2, "Limit Smart Hammer To Freezed", "", function() sc_smartHammerOnlyFreezed = 1 - sc_smartHammerOnlyFreezed end)
	
	
	
	MakeSimpleMenu('bot', Row3, "Copy Tee To Player", "Copy skin, name, etc of a selected tee to your player", function(btn)
		setFullPage('players', 'copyPlayer')
   		btn.Clicked = false
		
	end)
	
	MakeSimpleMenu('bot', Row3, "Copy Tee To Dummy", "Copy skin, name, etc of a selected tee to your dummy", function(btn)
		setFullPage('players', 'copyDummy')
   		btn.Clicked = false
		
	end)
	
	MakeSimpleCheckBox('bot', Row1, "Auto Aim Hook", "Hook bot", function() sc_AutoAimHook = 1 - sc_AutoAimHook end, true)
	MakeSimpleCheckBox('bot', Row1, "Auto Aim Fire", "Fire bot", function() sc_AutoAimFire = 1 - sc_AutoAimFire end, true)
	MakeSimpleCheckBox('bot', Row1, "Use Heuristic Aiming", "This will use LESS CPU and decrease lags. As a result Aim acurracy its downgraded a bit!", function() sc_UseHeuristicAim = 1 - sc_UseHeuristicAim end, true)
	MakeSimpleCheckBox('bot', Row1, "Check Player Hooking", "This will check tuning to see if its allowed to hook a player. TURN OFF IN ZOMBIE MOD!!!", function() sc_CheckForPlayerHooking = 1 - sc_CheckForPlayerHooking end, true)
	MakeSimpleCheckBox('bot', Row1, "A fun hammer hammer fly with your dummy!", "Get close to your dummy and press CTRL", function() sc_HammerHammerFly = 1 - sc_HammerHammerFly end, false)
	
--Tuning().player_hooking

	MakeSimpleCheckBox('bot', Row1, "Fast Fire", "Rapid fire", function() sc_FastFire = 1 - sc_FastFire end)
	MakeSimpleCheckBox('bot', Row1, "Fast Hook", "Fast rehook[Endless Hook]", function() sc_FastHook = 1 - sc_FastHook end)
	MakeSimpleCheckBox('bot', Row1, "Hook Nearest Collision", "Hook tile bot", function() sc_HookCol = 1 - sc_HookCol end)
	
	
	MakeSimpleCheckBox('bot', Row1, "Auto Dummy Hammer Fly", "Connect dummy and activate this", function()
		sc_AutoHammerFly = 1 - sc_AutoHammerFly
		Config.cl_dummy_hammer = sc_AutoHammerFly
	end)
	MakeSimpleCheckBox('bot', Row1, "Auto Dummy Hook Fly", "Connect dummy and hook your dummy", function() sc_DummyHookFly = 1 - sc_DummyHookFly end)
	--MakeSimpleCheckBox('bot', Row1, "Copy Dummy", "T1", function() Config.cl_dummy_copy_moves = 1 - Config.cl_dummy_copy_moves end)
	MakeSimpleCheckBox('bot', Row1, "Copy Dummy", "Dummy act same as you", function() sc_dummy_copy = 1 - sc_dummy_copy end)
	MakeSimpleCheckBox('bot', Row1, "Reverse Copy X/Axis", "Reverse target of X", function() sc_dummy_mirrorX = 1 - sc_dummy_mirrorX end)
	MakeSimpleCheckBox('bot', Row1, "Reverse Copy Y/Axis", "Reverse target of Y", function() sc_dummy_mirrorY = 1 - sc_dummy_mirrorY end)
	MakeSimpleCheckBox('bot', Row1, "Reverse Copy Direction", "Reverse direction", function() sc_dummy_direction = 1 - sc_dummy_direction end)
	
	--MakeSimpleCheckBox('bot', Row1, "Reverse Copy Dummy", "T1", function() Config.cl_dummy_copy_mirror = 1 - Config.cl_dummy_copy_mirror end)
	
	
	MakeSimpleCheckBox('bot', Row1, "Playback Bot [Record+Play]", "CTRL + Mouse Middle Button[CTRL+ALT+SHIFT+MOUSE MIDDLE = DELETE record!]", function() sc_StartRecord = 0 sc_PlaybackBot = 1 - sc_PlaybackBot end, true)
	MakeSimpleCheckBox('bot', Row1, "Playback Bot Restart At Fail", "When you fail to record a move, if you get back at start position automatically a new record will start!", function() sc_AutoRestartRecordOnFail = 1 - sc_AutoRestartRecordOnFail end, true)
	MakeSimpleCheckBox('bot', Row1, "Stop Playback At Fail", "When a pocket loss or error happened the playing its stoped", function() sc_StopAutoPlayOnError = 1 - sc_StopAutoPlayOnError end, true)
	MakeSimpleCheckBox('bot', Row1, "Draw Playback Predict", "While playing a record you will see predicted line of movements", function() sc_DrawPlaybackStuff = 1 - sc_DrawPlaybackStuff end, true)
	MakeSimpleCheckBox('bot', Row1, "Change Weapon Faster On Playback", "Ex for laser: This will help to unfreeze beter if you use multiple weapon on record[Disable if have problem]", function() sc_ChangeWeaponFasterOnPlayback = 1 - sc_ChangeWeaponFasterOnPlayback end, true)
	
	
	MakeSimpleCheckBox('bot', Row1, "Hookride Bot", "ALT + Mouse Right Button", function() sc_ZeroHookVel = 0 sc_HookrideBot = 1 - sc_HookrideBot end, true)
	MakeSimpleCheckBox('bot', Row1, "Jetride Bot", "ALT + Mouse Left Button", function() sc_JetpackRide = 0 sc_JetrideBot = 1 - sc_JetrideBot end, true)
	MakeSimpleCheckBox('bot', Row1, "Pixel Move Bot", "Aka Edge Bot! Move only a bit if ALT is hold!", function() sc_allowPixelMove = 1 - sc_allowPixelMove end, true)
	MakeSimpleCheckBox('bot', Row1, "Freeze Edge Bot", "Auto stand on edge of tile of freeze!", function() sc_DoEdgeBot = 1 - sc_DoEdgeBot end)
	
	
	
	
	

	
	
	MakeSimpleCheckBox('bot', Row1, "Auto Shoot Who Target You", "If anyone target you with any weapon then will get shooted by laser[FNG]", function() sc_autoHitTargeter = 1 - sc_autoHitTargeter end)
	MakeSimpleCheckBox('bot', Row1, "Auto Shoot Everybody", "Shoot anybody who is alive [FNG]", function() sc_autoHitAll = 1 - sc_autoHitAll end)
	MakeSimpleCheckBox('bot', Row1, "Auto Shoot Opposite Team", "Shoot anybody who is outside your team [FNG]", function() sc_autoHitOtherTeam = 1 - sc_autoHitOtherTeam end)
	MakeSimpleCheckBox('bot', Row1, "Auto Shoot Zombies", "Shoot all zombies", function() sc_autoHitZombie = 1 - sc_autoHitZombie end)
	
	MakeSimpleCheckBox('bot', Row1, "Use Wallshot Hit If Failed", "If we cant shoot straight then use wallshot hit[FNG]", function() sc_WallshotHit = 1 - sc_WallshotHit end, true)
	MakeSimpleCheckBox('bot', Row1, "Use Wallshot Hit ALWAYS", "Always hit enemies through wallshot[FNG]", function() sc_WallshotHitAlways = 1 - sc_WallshotHitAlways end)
	
	
	
	
end


function OnScriptUnload()

	Engine.Graphics:UnloadTexture(BlueTex) 
end

targetTicks = {}

function OnScriptInit()
	
	for ID = 0, 64, 1 do
		targetTicks[ID] = {}
	end
	
	local names = {
		--"algorithm",
		--"broadcast", 
		--"config"   ,
		--"debug"    , 
		--"general"  , 
		--"logger"   , 
		--"luac"     , 
		--"math"     , 
		--"queue"    , --conflict with either fs,zlib,mlib,bitser!
		--"sound"    , 
		--"sprites"  , 
		--"stringutils",
		"tune"     ,
		"twdata"   , 
		--"twutils"  , 
		--"types"    , --caused crash with remote loading!
		"ui"         
	}
	
	
	for nameCount = 1, #names do
		local success = Import(names[nameCount])
		if( not success) then
			Game.Console:Print(0, 'Failed to load ', '' .. names[nameCount] , 1)
			return false
		end
	end





 




	OnEnterGame()
	----Tex = Engine.Graphics:LoadTexture("data/textures/game/".. Config.tex_game ..".png",-1,-1,1)
	

	
	ContainersStart()
	
	--if(_ConfigGet("Configed") ~= SashBotVersion) then
	--	prn('First Automatic Config!')
	--	_ConfigSet("Configed", SashBotVersion)
	--	_ConfigSet("JetRideKey", "mouse1")
	--	_ConfigSet("HookRideKey", "mouse2")
	--	_ConfigSet("BalanceKey", "b")
	--	
	--	_ConfigSave()
	--	_ConfigLoad()
	--end
	
	NeonTeeTex = Engine.Graphics:LoadTexture("data/skins/Neontee.png",-1,-1,1)
	BlueTex = Engine.Graphics:LoadTexture("data/textures/game/blue.png",-1,-1,1)

	
	--if(BotRectArray == nil) then BotRectArray = {} end
	
	CalcRects()
		
	--local BtnRect = UIRect(100,100,100,25)
	--MakeAButton( "som text", BtnRect, "ATTip", function(BtnInfo) BtnInfo.Clicked = not BtnInfo.Clicked end  )
	--MakeATextBox( "som text", BtnRect, "ATTip", function(BtnInfo) BtnInfo.Clicked = not BtnInfo.Clicked end  )
	
	resetAvailableRecord()
	


	Config.cl_cpu_throttle = 0
	Config.cl_trans_in = 0
	Config.cl_trans_out = 0
	Config.cl_trans_chat_cmds = 0
 
	return true
end

function scHudDrawProperty(txt, prop, x, y, fontSize)
	if(prop == 1) then Engine.TextRender:TextColor(0,1,0,1) else Engine.TextRender:TextColor(1,0,0,1) end
	Engine.TextRender:Text(nil, x, y, fontSize,txt,-1)
	Engine.TextRender:TextColor(1,1,1,1)
	return Engine.TextRender:TextWidth(nil,fontSize,txt,-1,-1) + 10
end

_debugInfoStr = ""

function DrawLocalPlaybackTee(RectPos, inDir)

 	local MyTee = TeeRenderInfo() -- Ohne parameter???
	MyTee.Texture = NeonTeeTex
	--MyTee.ColorBody = Game.Players(Game.LocalCID).RenderInfo.ColorBody
	--MyTee.ColorFeet = Game.Players(Game.LocalCID).RenderInfo.ColorFeet
	MyTee.Size = 80
	MyTee.GotAirJump = 1
	--if(inDir == nil) then
	--	inDir = vec2(math.cos(Game.Client.LocalTime * 5), math.sin(Game.Client.LocalTime * 5))
	--end
	
	--Game.RenderTools:RenderTee( Game.CharSnap(DisplayID).Cur.Emote , MyTee , vec2f(math.cos(Game.Client.LocalTime * 5), math.sin(Game.Client.LocalTime * 5)) , vec2f(TeeWindow.x+TeeWindow.w/2,TeeWindow.y+TeeWindow.h/2),false,0)
	Game.RenderTools:RenderTee( Game.CharSnap(Game.LocalCID).Cur.Emote , MyTee , vec2f(inDir.x, inDir.y) , vec2f(RectPos.x+RectPos.w/2,RectPos.y+RectPos.h/2),false,0)

end

function DrawTee(TeeWindow,DisplayID,Size, inDir)
	-- Draw name at the Top

 	local MyTee = TeeRenderInfo() -- Ohne parameter???
	MyTee.Texture = Game.Players(DisplayID).RenderInfo.Texture
	MyTee.ColorBody = Game.Players(DisplayID).RenderInfo.ColorBody
	MyTee.ColorFeet = Game.Players(DisplayID).RenderInfo.ColorFeet
	MyTee.Size = Size or 80 --Game.Players(DisplayID).RenderInfo.Size
	MyTee.GotAirJump = Game.Players(DisplayID).RenderInfo.GotAirJump
	if(inDir == nil) then
		inDir = vec2(math.cos(Game.Client.LocalTime * 5), math.sin(Game.Client.LocalTime * 5))
	end
	--Game.RenderTools:RenderTee( Game.CharSnap(DisplayID).Cur.Emote , MyTee , vec2f(math.cos(Game.Client.LocalTime * 5), math.sin(Game.Client.LocalTime * 5)) , vec2f(TeeWindow.x+TeeWindow.w/2,TeeWindow.y+TeeWindow.h/2),false,0)
	Game.RenderTools:RenderTee( Game.CharSnap(DisplayID).Cur.Emote , MyTee , vec2f(inDir.x, inDir.y) , vec2f(TeeWindow.x+TeeWindow.w/2,TeeWindow.y+TeeWindow.h/2),false,0)
end


function Render()
	--if(sc_IsScriptEnabled ~= 1) then return end
	
	local MainView = Game.Ui:Screen()
	Engine.Graphics:MapScreen(0,0, MainView.w, MainView.h)

	
	Label = UIRect(Game.LocalTee.Pos.x, Game.LocalTee.Pos.y - 42 ,0 ,0)
 
	--Game.Ui:DoLabelScaled(Label, "Available Commands:", 15, -1, -1, nil)
	
	-- Real Hud begins here	
	local Screen = Game.Ui:Screen()
	--Engine.Graphics:MapScreen(0,0, Screen.w, Screen.h)

	-- Initialize all needed UIRect's
	local MainView = Screen:copy()
 	--local HUD = UIRect(0, MainView.h - 222, MainView.w, MainView.h)

	if(IsSashUnlocked()) then
		local HUD = UIRect(0, MainView.h - (MainView.h/15), MainView.w, MainView.h) 
		Game.RenderTools:DrawUIRect(HUD, vec4f(0,0,0,0.5),  _CUI.CORNER_ALL, 10)
		
		local nextX = scHudDrawProperty("", 1, HUD.x, HUD.y, 18)
		--local nextX = scHudDrawProperty("Bot(F11)", sc_IsScriptEnabled, HUD.x, HUD.y, 18)	
		nextX = nextX + scHudDrawProperty("1TempTest", sc_TempTest, nextX, HUD.y, 18)
		
		local teePosStr = 'Pos:' .. Game.LocalTee.Pos.x .. '    ' .. Game.LocalTee.Pos.y .. '  Vel:' .. Game.LocalTee.Vel.x .. '   ' .. Game.LocalTee.Vel.y
		nextX = nextX + scHudDrawProperty(teePosStr, sc_TempTest, nextX, HUD.y, 18)
		--nextX = nextX + scHudDrawProperty("HookTick " .. Game.LocalTee.HookTick, sc_TempTest, nextX, HUD.y, 18)
		nextX = nextX + scHudDrawProperty(_debugInfoStr , true, 0, HUD.y + 20, 18)
	end

	
	if(sc_StartRecord == 1) then
		Engine.TextRender:TextColor(1,0,0,1)
		Engine.TextRender:Text(nil, Screen.w/2-100, Screen.h/2-50, 20,"Recording Moves",-1)
		Engine.TextRender:TextColor(1,1,1,1)
	elseif(sc_StartRecord == 2) then
		Engine.TextRender:TextColor(0,1,0,1)
		Engine.TextRender:Text(nil, Screen.w/2-100, Screen.h/2-50, 20,"Playing Moves",-1)
		Engine.TextRender:TextColor(1,1,1,1)	
	end


	Engine.TextRender:TextColor(1,1,1,1)
 
end

function OriginalKeyPress(Key)
	
 
	--player_hooking
	if Key == "mouse2" and sc_AutoAimHook == 1 then
		local doLocalGrab = false
		
		if(sc_CheckForPlayerHooking == 1) then
			if(Game.Tuning().player_hooking.Value  > 0) then
				doLocalGrab = true
			else 
				doLocalGrab = false
			end
		else
			doLocalGrab = true
		end
		
		if(doLocalGrab == true) then
			--LimitR = 168100
			sc_AimAccuracy = 0.25
			LimitR = (Game:Tuning().hook_length:Get() + 28) * (Game:Tuning().hook_length:Get() + 28)
			Vic = Grab()
		end
	end

	if Key == "mouse1" and sc_AutoAimFire == 1 then
		--LimitR = 10000000
		sc_AimAccuracy = 2
		LimitR = Game:Tuning().laser_reach:Get() * Game:Tuning().laser_reach:Get() 
		Vic = Grab()

		if Game.LocalTee.Weapon == 3 then
			Gup = 1

			if UseG == 0 then
				Vic = -1
			end
		end

		Focus = 1
	end
end


function prn(inp)

	Game.Chat:AddLine(-2, 0,inp)
end

function onScriptDisable()
	sc_LastHookSelectedPlayerId = -1
	lastHookAimPos = vec2(0, 0)
	lastHookAimId = -1

end

setDummy = 0
 
 

function compressFile(inFilename, outFileName)
	local zlib = require('ffi-zlib')

	local f = io.open(inFilename, "rb")
	local out_f = io.open(outFileName, "wb")

	local input = function(bufsize)
		-- Read the next chunk
		local d = f:read(bufsize)
		if d == nil then
			return nil
		end
		return d
	end

	local output_table = {}
	local output = function(data)
		table.insert(output_table, data)
		local ok, err = out_f:write(data)
		if not ok then
			
			-- abort compression when error occurs
			return nil, err
		end
	end

	-- Compress the data
	local ok, err = zlib.deflateGzip(input, output)
	io.close(f)
	io.close(out_f)
	if not ok then
		
		return nil, err
	end

	return table.concat(output_table,'')
end

 


function compressString(inString, outFileName)
	local zlib = require('ffi-zlib')

	--local f = io.open(inFilename, "rb")
	local out_f = io.open(outFileName, "wb")

	local count = 0
	local input = function(bufsize)
		local start = count > 0 and bufsize*count or 1
		local finish = (bufsize*(count+1)-1)
		count = count + 1
		if bufsize == 1 then
			start = count
			finish = count
		end
		local data = inString:sub(start, finish)
		if(#data == 0) then
			return nil
		end
		
		return data
	end


	--local output_table = {} --strOut
	local output = function(data)
		--table.insert(output_table, data) --strOut
		local ok, err = out_f:write(data)
		if not ok then
			
			-- abort compression when error occurs
			return nil, err
		end
	end

	-- Compress the data
	local ok, err = zlib.deflateGzip(input, output)
	--io.close(f)
	io.close(out_f)
	if not ok then
		
		return nil, err
	end
	return ok
	--return table.concat(output_table,'') --strOut
end


function decompressFile(fileName)
	local zlib = require('ffi-zlib')

	local f = io.open(fileName, "rb")
	--local out_f = io.open('ex.exe', "wb")

	local input = function(bufsize)
		-- Read the next chunk
		local d = f:read(bufsize)
		if d == nil then
			return nil
		end
		return d
	end

	local output_table = {}
	local output = function(data)
		table.insert(output_table, data)
		--local ok, err = out_f:write(data)
		--if not ok then
		--	return nil, err
		--end
	end

	-- Decompress the data
	local ok, err = zlib.inflateGzip(input, output)
	
	io.close(f)
	--io.close(out_f)
	
	if not ok then
		return nil
	end

	return table.concat(output_table,'')
end

 
function decodeChar(hex)
	return string.char(tonumber(hex,16))
end
 
function decodeString(str)
	local output, t = string.gsub(str,"%%(%x%x)",decodeChar)
	return output
end
 
function encodeChar(chr)
	return string.format("%%%X",string.byte(chr))
end
 
function encodeString(str)
	local output, t = string.gsub(str,"[^%w]",encodeChar)
	return output
end



function findRecAtPos(inPos, inDistance)
	for i=1,#availRecPosArray,1 do
		
		if(Game.Collision:Distance(vec2(availRecPosArray[i].x, availRecPosArray[i].y), inPos) <= inDistance) then			
			local binary_data = decompressFile(availRecPosArray[i].dir .. '/' .. availRecPosArray[i].fullName)
			return bitser.loads(binary_data)
		end	
	end
	return {}
end

function deleteRecAtPos(inPos)
	for i=1,#availRecPosArray,1 do
		
		if(Game.Collision:Distance(vec2(availRecPosArray[i].x, availRecPosArray[i].y), inPos) <= 0) then
			fs.remove(availRecPosArray[i].dir .. '/' .. availRecPosArray[i].fullName)
			resetAvailableRecord()
			return true
		end	
	end
	return false
end

function saveARec(inPlayBackArray)
	finalFileName = Game.Players(Game.LocalCID).Name .. '_' .. 
				round2(inPlayBackArray[1].TeePosX) .. '_' ..
				round2(inPlayBackArray[1].TeePosY) .. '_' ..
				os.date("%y%m%d") .. '_' ..
				os.date("%H%M%S") .. '_' ..
				'Rez1' .. '_' ..
				'Rez2' .. '_' ..
				'Rez3'
				
	local binary_data = bitser.dumps(inPlayBackArray)
	--local copy_of_some_thing = bitser.loads(binary_data)
	--prn( encodeString(finalFileName) )
	compressString(binary_data, 'rec/' .. encodeString(Game.ServerInfo.Map) .. '/' .. encodeString(finalFileName) )
	
	resetAvailableRecord()
end

function isAltDown()
	return Engine.Input:KeyIsPressed("lalt") or Engine.Input:KeyIsPressed("ralt")
end


function isCtrlDown()
	return Engine.Input:KeyIsPressed("lctrl") or Engine.Input:KeyIsPressed("rctrl")
end



function isShiftDown()
	return Engine.Input:KeyIsPressed("lshift") or Engine.Input:KeyIsPressed("rshift")
end

	
string.startswith = function(self, str) 
    return self:find('^' .. str) ~= nil
end


 


function OnKeyPress(Key)
	--prn('' .. names_male[math.random(1, #names_male)])


	--Game.Console:Print(0, 'EZ', 'sssss' , 1)  -- 185.141.105.153:8308
	--Game.Console:Print(0, 'Erusi', Game.ServerInfo.IP , 1)
	--Game.Console:Print(0, 'name', Game.ServerInfo.Name , 1)
	--Game.Console:Print(0, 'Erusi', E('DBC2852C65C470604DC2E41CB1BC2C10DF66B3CCA7561A804CC2BFD019360E8021BEF1A413224770903837BCBC16BB60D4329D7C955A9D38C6A024ACB9640480') , 1)
	
	--Game.Console:Print(0, 'Erusi', PcHash()  , 1)
	--Game.Console:Print(0, 'Erusi', SashVersion()  , 1)

	if(Key == 'f5' and (HasLicense() == nil or HasLicense() == 'ExperimentalTrial') and SashTrialLicense == nil) then
		SashTrialLicense = 'Trial'
		setFullPage('bot')
		sc_ForceDisconnect = 0
	end

	if(HasLicense() == nil) then
		setFullPage('update')
	end
	
	--mousewheeldown
	--mousewheelup
	--mouse3
	if(Key == 'a' or Key == 'd') then
		doPixelMove = true
	end

	--prn('key : ' .. Key)
--	if(Key == 'f11') then
--		sc_IsScriptEnabled = 1 - sc_IsScriptEnabled
--		if(sc_IsScriptEnabled ~= 1) then onScriptDisable() end
	if(Key == 'mouse3' and sc_PlaybackBot == 1) then
		if(isAltDown() and isCtrlDown() and isShiftDown()) then
			--local exactRec = 
			if(deleteRecAtPos(Game.LocalTee.Pos)) then --there is a record EXACTLY here
				Game.HUD:PushNotification('Deleted record', vec4(1,0,0,1))
			else
				Game.HUD:PushNotification('Cant find any record to delete at this position!', vec4(0,1,1,1))
				
			end
			
		elseif(isCtrlDown() and not isAltDown() and not isShiftDown()) then
			if(sc_StartRecord == 0) then  --currently nothing
				local exactRec = findRecAtPos(Game.LocalTee.Pos, 0)
				if(#exactRec > 0) then --there is a record EXACTLY here
					
					sc_playbackArray = exactRec
					
					
					Game.Input.WantedWeapon = WEAPON_GUN 
					sc_FirstPlayDelay = 10 -- ticks
					
					sc_StartRecord = 2
					sc_sendPlaybackCount = 1
					Game.HUD:PushNotification('Playing record!', vec4(0,1,0,1))
					
					return
				end
				
				nearRec = findRecAtPos(Game.LocalTee.Pos, 34)
				if(#nearRec > 0) then
					Game.HUD:PushNotification('You cant start record near another record position!', vec4(1,0,0,1))
				elseif(math.abs(Game.LocalTee.Vel.x) > 0.1 or math.abs(Game.LocalTee.Vel.y) > 0.1) then
					Game.HUD:PushNotification('Stop your tee before try to record[Zero Velocity]', vec4(1,0,0,1))
				elseif(sc_UseHeuristicAim == 1) then
					Game.HUD:PushNotification('TURN OFF heuristic aiming before try to record', vec4(1,0,0,1))
				else
					restartRecordAtPos = nil
					sc_playbackArray = {}
					sc_StartRecord = 1
					Game.HUD:PushNotification('Recording started!', vec4(0,1,0,1))
					--sc_sendPlaybackCount = 1
				end
				
			elseif(sc_StartRecord == 1) then  --currently recording
				sc_StartRecord = 0
				saveARec(sc_playbackArray)
				Game.HUD:PushNotification('Recording stopped and saved!', vec4(0,1,1,1))
				
			elseif(sc_StartRecord == 2) then --currently playing a playback
				sc_StartRecord = 0
				sc_sendPlaybackCount = 1
			end
		 
		
		end
	
	elseif(sc_HookrideBot == 1 and Key.lower(Key) == 'mouse2') then
		if(isAltDown() and not isCtrlDown() and not isShiftDown()) then
			sc_JetpackRide = 0
			
			sc_ZeroHookVel = 1 - sc_ZeroHookVel				
			WantedPos = Game.LocalTee.Pos
		end
		
	elseif sc_JetrideBot == 1 and Key.lower(Key) == 'mouse1' then
		if(isAltDown() and not isCtrlDown() and not isShiftDown()) then
			sc_ZeroHookVel = 0
			
			sc_JetpackRide = 1 - sc_JetpackRide
			if(sc_JetpackRide == 0) then Game.Input.Fire = 0 end --prevent bug continues shoot after disable
			WantedPos = Game.LocalTee.Pos
		end
			
	 
	elseif(Key == 'f9') then
		--Game.Input.DummyFire = (Game.Input.DummyFire + 1) % 2
		--Game.Input.DummyFire = (Game.Input.DummyFire + 1) % 2
		--Game.Input.DummyDirection = 1
		setFullPage('bot')
	
	elseif(Engine.Input:KeyIsPressed("f12")) then
		setFullPage('players', 'activeBot')
		
	end
	
	if(sc_IsScriptEnabled ~= 1) then return end
	

	
	OriginalKeyPress(Key)
	 
	
	
	if(Key == 'mouse1') then
		--Game.HUD:PushNotification('' .. Game.Client.LocalTime - SashRunTime, vec4(1,0,0,1))
 

	end

		
	if(Key == 'mouse1') then
		scrollMousePos = vec2(Game.Ui:MouseX(), Game.Ui:MouseY())
		HandleMenuClicks()
		
		
		
	elseif(Key == 'f8') then
		--Config.cl_dummy = 1 - Config.cl_dummy	
		
		setDummy = 1
		
	end
	
	 

	--state check end
	
	return 
end

function HasLicense ()

	if(Game.Client.State ~= STATE_ONLINE) then
		--sc_ForceDisconnect = 0
		return "ExperimentalTrial"
	elseif( tostring(Game.ServerInfo.IP):startswith('80.249.113.28') or tostring(Game.ServerInfo.Name):startswith('DDPER - ')) then
	
		return "ExperimentalTrial"
	end
	
	if (_G["PcHash"] == nil) then
	  sc_ForceDisconnect = 1
	  return nil
	end
	--Game.Console:Print(0, 'cpuid ', CpuId(0, '%x') , 1)
	
	--Game.HUD:PushNotification(CpuId(0, '%x'), vec4(1,0,0,1))
	--Game.HUD:PushNotification(CpuId(0, '%d', 0), vec4(1,0,0,1))
	--Game.HUD:PushNotification(CpuId(0, '%d', 1), vec4(1,0,0,1))
	--Game.HUD:PushNotification(CpuId(0, '%d', 2), vec4(1,0,0,1))
	--Game.HUD:PushNotification(CpuId(0, '%d', 3), vec4(1,0,0,1))



	local foundLic = false
	for i = #listOfLiceses, 1, -1 do -- find the top-most one
		if(PcHash() == E(listOfLiceses[i].key) )then
			return listOfLiceses[i].owner
		end
	end
	
		
	if( Game.Client.LocalTime - SashRunTime < 5 * 60 and numOfSnaps < 5 * 3000) then
		return SashTrialLicense
	end
	
	sc_ForceDisconnect = 1

		
end

function Fly()
	if(sc_JetpackRide == 0 and sc_ZeroHookVel == 0) then 
		return
	end
	
	local eachMoveStep = 4
	local moveSensivity = eachMoveStep * 2
	
	if Engine.Input:KeyIsPressed("a") then
		WantedPos.x = WantedPos.x - eachMoveStep
	end

	if Engine.Input:KeyIsPressed("d") then
		WantedPos.x = WantedPos.x + eachMoveStep
	end

	if Engine.Input:KeyIsPressed("w") then
		WantedPos.y = WantedPos.y - eachMoveStep
	end

	if Engine.Input:KeyIsPressed("s") then
		WantedPos.y = WantedPos.y + eachMoveStep
	end

	local Priority = math.abs(Game.LocalTee.Pos.y - WantedPos.y)/6.685

	if Priority < 1 then
		Priority = 1
	end

	if WantedPos.y < Game.LocalTee.Pos.y then
		VMod = Priority*-0.75
	elseif Game.LocalTee.Pos.y < WantedPos.y then
		VMod = Priority*0.75
	else
		VMod = 0
	end

	if VMod < Game.LocalTee.Vel.y then
		if(sc_JetpackRide == 1) then
			Game.Input.TargetX = 0
			Game.Input.TargetY = 1
		
		
			Game.Input.Fire = 1
		elseif(sc_ZeroHookVel == 1 and (not Engine.Input:KeyIsPressed("mouse2")  )) then
			if( nextWallShotTarget == nil and nextWallshotHitTarget == nil and nextShootgunSelfshotPos == nil
				and shootAtTargeter == nil and shootAllNextCondidate == nil and sc_smartHammerNextId == -1) then
				if(setTargetToCol ~= nil) then
					Game.Input.TargetX = setTargetToCol.x
					Game.Input.TargetY = setTargetToCol.y
					
					--Game.Input.MouseX = setTargetToCol.x
					--Game.Input.MouseY = setTargetToCol.y
					
					setTargetToCol = nil
				end
				--if(Game.LocalTee.HookState == HOOK_GRABBED or Game.LocalTee.HookState == HOOK_RETRACTED ) then
				if(Game.LocalTee.HookState == HOOK_RETRACTED ) then
					Game.Input.Hook = 0
				elseif(Game.LocalTee.HookState == HOOK_GRABBED and (Game.LocalTee.Vel.y < 0 or Game.LocalTee.HookedPlayer ~= -1 )) then
					--or math.abs(Game.LocalTee.Vel.y) > 0 
					Game.Input.Hook = 0
				else
					Game.Input.Hook = 1
				end
				
			end
		end
		
	else
		if(sc_JetpackRide == 1) then
			Game.Input.Fire = 0
		elseif(sc_ZeroHookVel == 1 and (not Engine.Input:KeyIsPressed("mouse2") )) then
			Game.Input.Hook = 0
		end
	end

	if Game.LocalTee.Pos.x - WantedPos.x < -moveSensivity then
		Game.Input.Direction = 1
	elseif moveSensivity < Game.LocalTee.Pos.x - WantedPos.x then
		Game.Input.Direction = -1
	else
		Game.Input.Direction = 0
	end

	return 
end

function OriginalOnKeyRelease(Key)
	if Key == "mouse1" then
		Focus = 0
	end
	

	if(Key == 'mouse1') then
		HandleMenuClickRelease()
	end
	
	Vic = -1
end

function OnKeyRelease(Key)
	if(sc_IsScriptEnabled ~= 1) then return end
	
	OriginalOnKeyRelease(Key)

 
	return 
end

function Tar(x, y, xx, yy, Rly)
	local ax = xx - x
	local ay = yy - y
	local ac = Dis(x, y, xx, yy)
	local sx = x + ax/ac*TeeTall
	local sy = y + ay/ac*TeeTall
	local Us = Game.LocalTee.Pos
	local Them = Game.LocalTee.Pos
	Us.x = sx
	Us.y = sy
	Them.x = xx
	Them.y = yy

	--local tRes =Game.Collision:IntersectLine(Us, Them, nil, nil, false)
	--if(tRes ~= 0 and tRes ~= 1 and tRes ~= 3) then
	--	prn("a: " .. Game.Collision:IntersectLine(Us, Them, nil, nil, false))
	--end 
	if Game.Collision:IntersectLineTeleHook(Us, Them, nil, nil, false) == 0 then
		if Rly == 1 then
			if Gup == 1 then
				local Zav = math.deg(math.atan(ay/ax))

				if 0 < Zav then
					Zav = Zav*-1
				end

				Zav = Zav + 90.001
				Zav = math.sqrt(Zav)
				local Fas = (40 - ac )*(40 - ac)
				local Ini = 20
				Gup = Ini - Fas*Zav*Con

			end

			Game.Input.TargetX = xx - x
			Game.Input.TargetY = yy - y + Gup
		end

		return 1
	end

	return 0
end


function round2(num, numDecimalPlaces)
  return tonumber(string.format("%." .. (numDecimalPlaces or 0) .. "f", num))
end



function SetAim(Who, Rly)
	local anax, anay, anaxx, anayy = nil
	local anax = LPosx()
	local anay = LPosy()
	local anaxx = Posx(Who)
	local anayy = Posy(Who)
	
	local foundARad = 0
	local foundBRad = 0
	local startRad = -1
	local endRad = -1
	
	if(sc_UseHeuristicAim == 1) then
		sc_AimAccuracy = 2
	end
	
	for TeeRad = 0, TeeRadConst, sc_AimAccuracy do
		if  Tar(anax, anay, anaxx - TeeRad, anayy - TeeRad, Rly) == 0 and Tar(anax, anay, anaxx - TeeRad, anayy + TeeRad, Rly) == 0 and Tar(anax, anay, anaxx + TeeRad, anayy - TeeRad, Rly) == 0 and Tar(anax, anay, anaxx + TeeRad, anayy + TeeRad, Rly) == 0 then
			if Rly == 1 and UseDD == 1 then
				Game.Input.TargetX = anaxx - anax
				Game.Input.TargetY = anayy - anay
			end
			--return 0
		else
			foundARad = 1
			startRad = TeeRad
			break
		end
	end
	
	for TeeRad = TeeRadConst, 0, -sc_AimAccuracy do
		if  Tar(anax, anay, anaxx - TeeRad, anayy - TeeRad, Rly) == 0 and Tar(anax, anay, anaxx - TeeRad, anayy + TeeRad, Rly) == 0 and Tar(anax, anay, anaxx + TeeRad, anayy - TeeRad, Rly) == 0 and Tar(anax, anay, anaxx + TeeRad, anayy + TeeRad, Rly) == 0 then
			if Rly == 1 and UseDD == 1 then
				Game.Input.TargetX = anaxx - anax
				Game.Input.TargetY = anayy - anay
			end
			--return 0
		else
			foundBRad = 1
			endRad = TeeRad
			break
		end
	end
	
	
	if( foundBRad == 1 and foundARad == 1) then
		
		TeeRad = ((startRad + endRad)/2)
		--prn(startRad .. "     " .. endRad .. "      " .. TeeRad)
		if  Tar(anax, anay, anaxx - TeeRad, anayy - TeeRad, Rly) == 0 and Tar(anax, anay, anaxx - TeeRad, anayy + TeeRad, Rly) == 0 and Tar(anax, anay, anaxx + TeeRad, anayy - TeeRad, Rly) == 0 and Tar(anax, anay, anaxx + TeeRad, anayy + TeeRad, Rly) == 0 then
			if Rly == 1 and UseDD == 1 then

				Game.Input.TargetX = anaxx - anax
				Game.Input.TargetY = anayy - anay
			end
			--return 0
		end
		
	end
	
	return foundBRad
end

function InRange(Who)
	local rxx = LPosx() - Posx(Who)
	local ryy = LPosy() - Posy(Who)

	if rxx*rxx + ryy*ryy <= 168100 then
		return 1
	end

	return 0
end








function meanAngle (angleList)
  local sumSin, sumCos = 0, 0
  for i, angle in pairs(angleList) do
    sumSin = sumSin + math.sin(math.rad(angle))
    sumCos = sumCos + math.cos(math.rad(angle))
  end
  local result = math.deg(math.atan2(sumSin, sumCos))
  return string.format("%.2f", result)
end
 

 

function DummyFireAtPos(PosOrDir)
	Game.Input.DummyTargetX = PosOrDir.x
	Game.Input.DummyTargetY = PosOrDir.y
	--Game.Console:Print(0, 'Game.Input.DummyFire', Game.Input.DummyFire , 1)
 
	--Game.Input.DummyFire = (Game.Input.Fire + 2) % 64 --idk why DummyFire not works	
	--Game.Input.DummyFire = (Game.Input.Fire - Game.Input.DummyFire) + 1--idk why DummyFire not works	 
	--Game.Input.DummyFire = (Game.Input.DummyFire - Game.Input.Fire )  --idk why DummyFire not works	
	Game.Input.DummyFire = (Game.Input.Fire + 2) % 64	
	
end

function FireAtPos(PosOrDir)
	WillIUseFire = true
	Game.Input.TargetX = PosOrDir.x
	Game.Input.TargetY = PosOrDir.y
	Game.Input.Fire = (Game.Input.Fire + 2) % 64
end

function PossibleToLaser(inPlayerID)
	local VictimPos = Game.Players(inPlayerID).Tee.Pos
	if(inPlayerID ~= nil and Game.Players(inPlayerID).Active and Game.CharSnap(inPlayerID).Active) then
		--if(TW.Game:IntersectCharacter(Game.LocalTee.Pos, VictimPos, nil, Game.LocalCID ) == inPlayerID) then
			if(Game.Collision:IntersectLine(Game.LocalTee.Pos, VictimPos, nil, nil, false) == 0) then
				if(Game.Collision:Distance(Game.LocalTee.Pos, VictimPos) < Game:Tuning().laser_reach:Get()) then
					return true
				end
			end
		--end
	end
	return false
end

function PossibleToLaserOtherTeam(inPlayerID)
	
	if(PossibleToLaser(inPlayerID)) then
		if( Game.Snap:PlayerInfos(inPlayerID).Team ~= Game.Snap:PlayerInfos(Game.LocalCID).Team ) then return true end
	end
	return false
end

function LaserShootPlayer(inPlayerID)
	if(PossibleToLaser(inPlayerID)) then
		--FireAtPos(Game.Players(inPlayerID).Tee.Pos)
		FireAtPos(Game.Players(inPlayerID).Tee.Pos - Game.LocalTee.Pos)
		 
	end
end

function IncreasePingBy(incAmount)
	Config.ClFakePingInc = incAmount
	Config.ClFakePingDec = 0
end


function DecreasePingBy(incAmount)
	Config.ClFakePingInc = 0
	Config.ClFakePingDec = incAmount
end

function setFullPage(inPage, extraOption)


--Game.Console:Print(0, 'numOfSnaps: ',numOfSnaps , 1)
	if (_G["PcHash"] ~= nil) then
		if(HasLicense() == nil or HasLicense() == 'Trial') then
			Game.Console:Print(0, 'Register Your Hardware: ', PcHash() , 1)

		end
		
	  
	end



	if(inPage == 'update' ) then
		if( sc_ForceUpdateClient == 1) then
		
			return
		end
		if( sc_ForceLicenseClient == 1 ) then
			return
		end
	end

 
	sc_ForceLicenseClient = 0
	sc_ForceUpdateClient = 0
	sc_SelectActivePlayers = 0
	sc_BotOptionPage = 0
	sc_ActiveFullscreenPage = ''
	sc_BotMenuSelectPlayerReason = ''
	--others
	
	if(sc_IsFullScreen and (extraOption == nil or extraOption == 'activeBot')) then
		
		ExitFullscreen()
		
	else
		sc_ActiveFullscreenPage = inPage
		if(inPage == 'bot') then
			sc_BotOptionPage = 1
		elseif(inPage == 'players') then
			sc_SelectActivePlayers = 1
			sc_BotMenuSelectPlayerReason = extraOption
		elseif(inPage == 'update') then
			if(SashVersion() ~= SashExeVer and SashDebugIgnoreVer == false) then
				sc_ForceUpdateClient = 1
				sc_ForceDisconnect = 1
			elseif(HasLicense() == nil) then
				sc_ForceLicenseClient = 1
				sc_ForceDisconnect = 1
			end
		end
		
		EnterFullscreen()
	end
	
	
	
end


PlaybackLines = {}
PlaybackLinesM = {}--Hooks
PlaybackLinesF = {}--Fires


WillIUseFire = false


numOfSnaps = 0
function OnSnapInput()
	WillIUseFire = false
	
	numOfSnaps = numOfSnaps + 1
	
  
	_debugInfoStr = 'att:' .. getPlayerWaitTimeFire(Game.LocalCID)
	
	
	--Game.Input.DummyFlags = bit.bor(Game.Input.DummyFlags, 512+256)
	--Game.Input.Flags = bit.bor(Game.Input.Flags, 512+256)
	
	--Game.Input.Flags = 1
	--local res = Game.Collision:TestBox(Game.LocalTee.Pos, vec2(28,28))
	--if(res) then prn('YES') end
	
	
	
	if(sc_StartRecord == 2) then
		if(sc_FirstPlayDelay ~= nil) then
			if(Game.CharSnap(Game.LocalCID).Cur.Weapon == WEAPON_GUN) then
				Game.Input.Fire = sc_playbackArray[1].Fire --prevent start fire bug
				Game.Input.TargetX = 0 --prevent start fire bug
				Game.Input.TargetY = 1 --prevent start fire bug
				sc_FirstPlayDelay = nil
				return
			end
			
			
			
			if(sc_FirstPlayDelay > 0) then
				sc_FirstPlayDelay = sc_FirstPlayDelay - 1
			else 
				sc_FirstPlayDelay = nil
			end
			return
		end
		
		PlaybackLines = {}
		PlaybackLinesM = {}
		PlaybackLinesF = {}
		--drawing lines
		for ci = 1, 50, 1 do
			local checkForPreEnable = sc_sendPlaybackCount + ci
			if(checkForPreEnable <= #sc_playbackArray) then
				local preRec = sc_playbackArray[checkForPreEnable-1]
				local nextRec = sc_playbackArray[checkForPreEnable]
				
				table.insert(PlaybackLines, LineItem(preRec.TeePosX, preRec.TeePosY,
					nextRec.TeePosX ,nextRec.TeePosY)) -- add a new line
				
				if(preRec.Hook ~= nextRec.Hook and preRec.Hook == 0) then
					table.insert(PlaybackLinesM, LineItem( preRec.TeePosX , preRec.TeePosY,
						 preRec.TargetX + preRec.TeePosX , preRec.TargetY + preRec.TeePosY)) -- add a new line
				end
				
				if(preRec.Fire ~= nextRec.Fire and preRec.Fire%2 == 0) then
					table.insert(PlaybackLinesF, LineItem( preRec.TeePosX , preRec.TeePosY,
						 preRec.TargetX + preRec.TeePosX , preRec.TargetY + preRec.TeePosY)) -- add a new line
				end
					
			end
		end
		
		
		if(sc_sendPlaybackCount <= #sc_playbackArray) then
			local TeePosInRec = vec2( sc_playbackArray[sc_sendPlaybackCount].TeePosX, sc_playbackArray[sc_sendPlaybackCount].TeePosY)
			local TeePosDiffWithRec = Game.Collision:Distance( TeePosInRec, Game.LocalTee.Pos)
			if(sc_StopAutoPlayOnError == 1 and TeePosDiffWithRec > 200) then
				Game.HUD:PushNotification('Error Occured While Playing', vec4(1,0,0,1))
				sc_StartRecord = 0
				sc_sendPlaybackCount = 1
				--prn('' .. Game.Collision:Distance( TeePosInRec, Game.LocalTee.Pos))
			end
			
			--_debugInfoStr = 'playframe: ' .. sc_sendPlaybackCount
			
			Game.Input.Direction = sc_playbackArray[sc_sendPlaybackCount].Direction
			
			Game.Input.Fire = sc_playbackArray[sc_sendPlaybackCount].Fire
			Game.Input.Hook = sc_playbackArray[sc_sendPlaybackCount].Hook
			Game.Input.Jump = sc_playbackArray[sc_sendPlaybackCount].Jump
			if(sc_playbackArray[sc_sendPlaybackCount].WantedWeaponProced == nil) then
				Game.Input.WantedWeapon = sc_playbackArray[sc_sendPlaybackCount].WantedWeapon
			end
			Game.Input.TargetX = sc_playbackArray[sc_sendPlaybackCount].TargetX
			Game.Input.TargetY = sc_playbackArray[sc_sendPlaybackCount].TargetY
			
			 
			sc_sendPlaybackCount = sc_sendPlaybackCount + 1
	 
			
			if(sc_ChangeWeaponFasterOnPlayback == 1) then
				for ci = 1, 20, 1 do
					local checkForPreEnable = sc_sendPlaybackCount + ci
					if(checkForPreEnable <= #sc_playbackArray) then
						--wantedweapon
						if(ci <= 20) then
							sc_playbackArray[sc_sendPlaybackCount].WantedWeaponProced = true
							if(sc_playbackArray[sc_sendPlaybackCount].WantedWeapon ~= sc_playbackArray[checkForPreEnable].WantedWeapon) then
								--prn('ci ' .. ci)
								Game.Input.WantedWeapon = sc_playbackArray[checkForPreEnable].WantedWeapon
								--break
							end
							 
						end
					end
				end
			end
		else
			sc_sendPlaybackCount = 1
			sc_StartRecord = 0
			
			
			--if autoplayback
			local exactRec = findRecAtPos(Game.LocalTee.Pos, 0)
			if(#exactRec > 0) then --there is a record EXACTLY here
				sc_playbackArray = exactRec
				sc_StartRecord = 2
				sc_sendPlaybackCount = 1
				Game.HUD:PushNotification('Auto continue record!', vec4(0,1,0,1))
				
				
				return
			end
			
		end
		
		return
	end



	for ID = 0, 64, 1 do
		if(Game.Players(ID).Active) then 
			local ptime = (Game.CharSnap(ID).Cur.AttackTick-(Game.Client.Tick-(0)))/50
			if(ptime > -0.05 and ptime < 0.05) then
				OnPlayerPredAttack(ID)
				
			end
		end
	end

	if(sc_LimitTeeVelocity > 0) then
		if( math.abs(Game.LocalTee.Vel.x) > sc_LimitTeeVelocity) then
			if(Game.LocalTee.Vel.x > 0) then
				Game.Input.Direction = -1
			else
				Game.Input.Direction = 1
			end
		end
		
		
		
	end
	
	if(sc_BalanceFromHooker == 1) then
		
		for ID = 0, 64, 1 do
			if(Game.Players(ID).Active) then 
				if( Game.Players(ID).Tee.HookedPlayer  == Game.LocalCID and Game.Players(ID).Tee.HookState == HOOK_GRABBED ) then
					if(Game.Players(ID).Tee.Pos.y < Game.Players(Game.LocalCID).Tee.Pos.y ) then 
						--on balaye mane
						--prn('hooked me   ' .. ID .. '   ' .. Game.LocalCID .. '    ' .. Game.Players(ID).Tee.HookState)
						--if(Game.Collision:IntersectLine(Game.LocalTee.Pos, Game.Players(ID).Tee.Pos, nil, nil, false) == 0) then				
							if(Game.LocalTee.Pos.x - Game.Players(ID).Tee.Pos.x > 2) then
								Game.Input.Direction = -1
							elseif(Game.Players(ID).Tee.Pos.x - Game.LocalTee.Pos.x > 2) then
								Game.Input.Direction = 1
							
							end
						--end
					end
					
					
				end
			end
		end
	end
	
	

	if(doEdgeLeft == true) then
		Game.Input.Direction = -1
		doEdgeLeft = false
	end
	
	if(doEdgeRight == true) then
		Game.Input.Direction = 1
		doEdgeRight = false
	end
	
	

	if(sc_allowPixelMove == 1) then
		if(isAltDown()) then
			if(doPixelMove) then
				doPixelMove = false
			else	
				Game.Input.Direction = 0
			end
		end
	end
	
	
	if(sc_lagyMovement > 0) then
		local lagReminder = Game.Client.Tick % 10
		if(lagReminder < (2 * sc_lagyMovement)) then
			Game.Input.Direction = -Game.Input.Direction
			--return
		end
	end
	
	if(sc_lagyHook == 1) then

		if(Engine.Input:KeyIsPressed("mouse2") ) then
			if(Game.LocalTee.HookState == HOOK_GRABBED or Game.LocalTee.HookState == HOOK_RETRACTED) then
				Game.Input.Hook = 0
			else
				OriginalKeyPress('mouse2')
				Game.Input.Hook = 1
			end
			
		end
	end
	
	--if(rec == true) then
	--	table.insert(Lines, LineItem(LastLinePos.x, LastLinePos.y, nres.x, nres.y))
	--end
	--if(setDummy == 1) then
	--	Config.cl_dummy = 1 - Config.cl_dummy
	--	Game.Input.Fire = (Game.Input.Fire + 1)%2
	--	setDummy = 2
	--elseif(setDummy == 2) then
	--	Config.cl_dummy = 1 - Config.cl_dummy
	--	Game.Input.Fire = (Game.Input.Fire + 1)%2
	--	setDummy = 0
	--end
	--if(Game.LocalTee.Pos.y == 9809) then
	--	_debugInfoStr = ""
	--end
	--if( math.abs(Game.LocalTee.Pos.y - 10924) < 10 and Game.Input.Hook == 0) then
		--Game.Input.TargetX = -17
		--Game.Input.TargetY = -294
		--Game.Input.Hook = 1
	--end
	--if(Game.Input.Hook == 1 and string.len(_debugInfoStr) == 0 ) then
	--	_debugInfoStr = "x: " .. Game.LocalTee.Pos.x .. "   y: " .. Game.LocalTee.Pos.y .. "    tx:" .. Game.Input.TargetX .. "   ty:" .. Game.Input.TargetY
	--end
	
	if(sc_IsScriptEnabled ~= 1) then return end
	

	--dummyTick = dummyTick + 1
	--if(dummyTick % 50 == 49) then
	--	Config.cl_dummy = 1 - Config.cl_dummy
	--end
	if(sc_AutoAimFire == 1 or sc_AutoAimHook == 1) then
		Grab() --colorize the hookable tee
	else 
		lastHookAimId = -1
	end
	
	HaltLook = 0

	if Focus == 0 and Game.LocalTee.HookedPlayer ~= -1 then
		HaltLook = 1
	end

	if Vic ~= -1 and HaltLook == 0 then
		SetAim(Vic, 1)
	end

	Gup = 0



	if( nextWallShotTarget ~= nil) then
		FireAtPos(nextWallShotTarget)
		nextWallShotTarget = nil
		

	end
	
	if(nextWallshotHitTarget ~= nil) then
		FireAtPos(nextWallshotHitTarget)
		nextWallshotHitTarget = nil
	end
	
	
	if(Engine.Input:KeyIsPressed("mouse1")  and nextShootgunSelfshotPos ~= nil) then
		FireAtPos(nextShootgunSelfshotPos)
		--Game.Input.TargetX = nextShootgunSelfshotPos.x
		--Game.Input.TargetY = nextShootgunSelfshotPos.y
		nextShootgunSelfshotPos = nil
	end
	
	
	if(Engine.Input:KeyIsPressed("f3")) then
		--prn('zz' .. numberToBinStr(31))
		--prn( tostring(Game.Menus.Active) .. '  ' .. tostring(Game.Menus.ActivePage))
		

		
		local meanDisToTile = (TeeSize / 2) + 1
		
		if( Game.Collision:GetTile(Game.LocalTee.Pos.x, Game.LocalTee.Pos.y + meanDisToTile) ~= 0) then
			if( Game.Collision:GetTile(Game.LocalTee.Pos.x - meanDisToTile, Game.LocalTee.Pos.y) ~= 0 or
				Game.Collision:GetTile(Game.LocalTee.Pos.x + meanDisToTile, Game.LocalTee.Pos.y) ~= 0) then
					--prn('Candidate pos to rec')
				end
		end
		
		
		--prn(Game.Players(Game.LocalCID).Tee.Angle/256 .. '    hit') 
		--os.exit(0)
	end
	

	
	
	
	if(not Engine.Input:KeyIsPressed("mouse1")) then
		if(shootAtTargeter ~= nil) then
			LaserShootPlayer(shootAtTargeter)
			shootAtTargeter = nil
		end
		
		if(shootAllNextCondidate ~= nil) then
			LaserShootPlayer(shootAllNextCondidate)
			shootAllNextCondidate = nil
		end
	end
	
	
	
	if(Engine.Input:KeyIsPressed("mouse2") and sc_FastHook == 1 ) then
		--local setHookState = false
		if(Game.LocalTee.HookState == HOOK_RETRACTED) then
			Game.Input.Hook = 0
			setHookState = true
		elseif(Game.LocalTee.HookState == HOOK_GRABBED) then
			if(Game.LocalTee.HookedPlayer == -1) then
				Game.Input.Hook = 0
				setHookState = true
			elseif( sc_IsBotAllowed[Game.LocalTee.HookedPlayer] == 0) then
				Game.Input.Hook = 0
				setHookState = true
			
			end
		else			
			OriginalKeyPress('mouse2')
			Game.Input.Hook = 1		
		end
		
	end
	 
	if(Engine.Input:KeyIsPressed("mouse1") and sc_FastFire == 1) then
		Game.Input.Fire = (Game.Input.Fire + 1) % 64
	end
	
	if(sc_DummyHookFly == 1) then
		--Game.MainID .. '    id2:' .. Game.DummyID
		if((Game.Client:DummyConnected())) then
			
			local MainPos = Game.LocalTee.Pos
			local DummyPos = Game.Players(Game.DummyID).Tee.Pos
			
			if(Config.cl_dummy == 1 ) then
				DummyPos = Game.Players(Game.MainID).Tee.Pos
			end

			local mdDir = MainPos - DummyPos			
			if(DummyPos.y < MainPos.y and Game.Collision:Distance(DummyPos, MainPos) > 16) then
				Game.Input.DummyTargetX = mdDir.x
				Game.Input.DummyTargetY = mdDir.y
				Game.Input.DummyHook = 1
			else
				Game.Input.DummyHook = 0
			end

			--if(((CGameClient *)GameClient())->m_aClients[m_LocalIDs[!g_Config.m_ClDummy]].m_Predicted.m_HookState == HOOK_RETRACTED || distance(Dummy, Main) < 48)
			if(Game.Collision:Distance(DummyPos, MainPos) < 48) then
				Game.Input.DummyHook = 0
			end
			
		end
		
	end
	
	if(sc_smartHammer > 0 and sc_smartHammerNextId ~= -1) then
		FireAtPos( Game.Players(sc_smartHammerNextId).Tee.Pos - Game.LocalTee.Pos )
		sc_smartHammerNextId = -1
	end
	
	
	
	if(sc_shootDummy == 1) then
		if((Game.Client:DummyConnected())) then
			Game.Input.DummyFire = (Game.Input.Fire + 2) % 64		
		end
	elseif(sc_shootDummy == 2) then
		if((Game.Client:DummyConnected())) then
			
			local MainPos = Game.LocalTee.Pos
			local DummyPos = Game.Players(Game.DummyID).Tee.Pos
			--
			--if(Config.cl_dummy == 1 ) then
			--	DummyPos = Game.Players(Game.MainID).Tee.Pos
			--end
			
			local lookDeg2 = MainPos - DummyPos
			DummyFireAtPos(lookDeg2)
			
		end
	end
	
	if( sc_AutoHammerFly == 1) then
	
		local MainPos = Game.LocalTee.Pos
		local DummyPos = Game.Players(Game.DummyID).Tee.Pos
		
		if(Config.cl_dummy == 1 ) then
			DummyPos = Game.Players(Game.MainID).Tee.Pos
		end
		
		
 
		--	Game.Input.DummyFire = (Game.Input.DummyFire + 1) % 10
		--	local lookDeg = MainPos - DummyPos
		--	Game.Input.DummyTargetX = lookDeg.x
		--	Game.Input.DummyTargetY = lookDeg.y
 

		local setHookState = false
		if(Game.LocalTee.HookState == HOOK_RETRACTED) then
			Game.Input.Hook = 0
			setHookState = true
		elseif(Game.LocalTee.HookState == HOOK_GRABBED and Game.LocalTee.HookedPlayer ~= Game.MainID and Game.LocalTee.HookedPlayer ~= Game.DummyID) then
			Game.Input.Hook = 0
			setHookState = true			
		end
		
		if( not setHookState) then
			Game.Input.Hook = 1
			local lookDeg2 = DummyPos - MainPos
			Game.Input.TargetX = lookDeg2.x
			Game.Input.TargetY = lookDeg2.y
		end
	end
 
	if(sc_TempTest == 1) then
		


 
 --Game.Input.Fire = (Game.Input.Fire + 1) % 10
		
		--Game.Input.DummyDirection    = Game.Input.Direction     
		--Game.Input.DummyFire         = Game.Input.Fire - lastInputData[Config.cl_dummy].Fire          
		--Game.Input.DummyHook         = Game.Input.Hook          
		--Game.Input.DummyJump         = Game.Input.Jump          
		--Game.Input.DummyWantedWeapon = Game.Input.WantedWeapon  
		--Game.Input.DummyTargetX      = Game.Input.TargetX       
		--Game.Input.DummyTargetY      = Game.Input.TargetY       
		
		
	end
	
	
	--if(XYLaser ~= nil) then
	--	XYLaser = XYLaser * 100
	--	Game.Input.TargetX = XYLaser.x
	--	Game.Input.TargetY = XYLaser.y
	--	Game.Input.Fire = Game.Input.Fire + 1
	--	XYLaser = nil
	--else
	--	Game.Input.Fire = 0
	--end
	 
	
	
	if(sc_HookCol == 1 and Game.Input.Hook == 1 or sc_ZeroHookVel == 1) then
	--prn(Game.Input.MouseX   .. '   ' .. Game.Input.MouseY)
		--X 0 Y -256
		local incDegEachTry = sc_CollFindStep / 100
		local clStart = Game:Tuning().hook_length:Get()/3
		local clEnd = Game:Tuning().hook_length:Get()
		if(sc_ZeroHookVel == 0) then
			clStart = Game:Tuning().hook_length:Get()
		end
		for checkLen = clStart , clEnd, clStart do
			local TuneHLen = checkLen
		
			
			--local TuneHLen = Game:Tuning().hook_length:Get()
			local startFindFrom = vec2(Game.Input.MouseX, Game.Input.MouseY)
			local maxAllowedDegree = sc_MaximumColHokDegree
			if(sc_ZeroHookVel == 1) then
				startFindFrom = vec2(0, -256)
				maxAllowedDegree = sc_MaximumRideColHokDegree
			end
			
			local startFindFromRadian = HeadVectorToRadian(startFindFrom.x, startFindFrom.y)
			
			local HookLenLimit = 42 + 17 --42 = teetall and 16 half of a tile to reach its center
			local colPos = vec2(0,0)
			local beforeColPos = vec2(0,0)
	 
			local startCol = nil
			local endCol = nil
			 
			
			local HookStartPos = Game.LocalTee.Pos + GetDir( startFindFromRadian) * 28 * 1.5
			
			local dirOfHook = GetDir( startFindFromRadian) * (TuneHLen - HookLenLimit)
			local hookPos = HookStartPos + dirOfHook
			local hokColTile = Game.Collision:IntersectLineTeleHook(HookStartPos, hookPos, colPos, beforeColPos, false) 
			
			--prn('X')
			--prn(' hokColTile: ' .. hokColTile)
			if(hokColTile == 3 or hokColTile == 0 or sc_ZeroHookVel == 1) then
				
				local positiveDeg = nil
				local negativeDeg = nil
				for degI = 0, maxAllowedDegree, incDegEachTry do
					dirOfHook = GetDir( startFindFromRadian + (const_degInRad * degI)) * (TuneHLen - HookLenLimit)
					hookPos = HookStartPos + dirOfHook
					hokColTile = Game.Collision:IntersectLineTeleHook(HookStartPos, hookPos, colPos, beforeColPos, false)
					
					if(hokColTile == 1) then
						positiveDeg = degI
						break
					end
						
				end		
				for degI = 0, -maxAllowedDegree, -incDegEachTry do
					dirOfHook = GetDir( startFindFromRadian + (const_degInRad * degI)) * (TuneHLen - HookLenLimit)
					hookPos = HookStartPos + dirOfHook
					hokColTile = Game.Collision:IntersectLineTeleHook(HookStartPos, hookPos, colPos, beforeColPos, false)
					
					if(hokColTile == 1) then
						negativeDeg = degI
						break
					end
						
				end
				
				--if(positiveDeg ~= nil) then prn( 'PD:' .. positiveDeg) end
				--if(negativeDeg ~= nil) then prn( 'ND:' .. negativeDeg) end
				
				local forSt = 1
				local forEd = 0
				local forSp = 1
				
				if(positiveDeg ~= nil and negativeDeg ~= nil) then
					if(math.abs(positiveDeg) < math.abs(negativeDeg)) then
						forSt = positiveDeg + 10
						forEd = positiveDeg
						forSp = -incDegEachTry
					else
						forSt = negativeDeg - 10
						forEd = negativeDeg
						forSp = incDegEachTry
					end
					
				elseif(positiveDeg ~= nil or negativeDeg ~= nil) then
					if(positiveDeg ~= nil) then
						forSt = positiveDeg 
						forEd = positiveDeg + 10
						forSp = incDegEachTry
					elseif(negativeDeg ~= nil) then
						forSt = negativeDeg
						forEd = negativeDeg - 10
						forSp = -incDegEachTry
					end
				end
				
				--_debugInfoStr = "forSt:"  .. forSt .. "  forEd:" .. forEd .. " forSp:" .. forSp .. "  "
				--prn(_debugInfoStr)
				--_debugInfoStr = ""
				for degI = forSt, forEd, forSp do
					dirOfHook = GetDir( startFindFromRadian + (const_degInRad * degI)) * (TuneHLen - HookLenLimit)
					hookPos = HookStartPos + dirOfHook
					hokColTile = Game.Collision:IntersectLineTeleHook(HookStartPos, hookPos, colPos, beforeColPos, false)
					
					--prn('degI : ' .. degI)
					if(hokColTile == 1) then
						--prn('DONE')
						if(startCol == nil) then
							
							--_debugInfoStr = _debugInfoStr .. degI .. "<d1    d2>"
							
							startCol = vec2( colPos.x, colPos.y)
						end
						endCol = vec2( colPos.x, colPos.y) 
					else
						--break
					end
					
				 
				end 
				--prn( 'startCol:' .. round2(startCol.x,2) .. '    ' .. round2(startCol.y,2) .. '   endCol' .. round2(endCol.x,2) .. '     ' .. round2(endCol.y,2) )
				if(startCol ~= nil and endCol ~= nil ) then
					
					
					local sd = startCol - Game.LocalTee.Pos
					local sdRad = HeadVectorToRadian(sd.x, sd.y)
					
					local sd2 = endCol - Game.LocalTee.Pos
					local sdRad2 = HeadVectorToRadian(sd2.x, sd2.y) 
					
					
					--local tempPrnDeg = ((sdRad2 + sdRad)/2)*180/PI
					--local newTempPrnRad = meanAngle({350, 10})
					--prn('s:'  .. round2(sdRad,2) .. '   e:' .. round2(sdRad2,2) .. "   deg:" .. round2(tempPrnDeg,1) .. ' ((sdRad2 + sdRad)/2):' .. round2((sdRad2 + sdRad)/2,2) )
					
					if( (sdRad < 0 and sdRad2 > 0) or (sdRad > 0 and sdRad2 < 0) ) then --if both have different signs then bug occurs we have to add one full circle 2PI to only one of them
						sdRad = sdRad + (PI * 2)
						--sdRad2 = sdRad2 + (PI * 2)
						--prn('BUG')
					end
					--if( math.abs((sdRad2 + sdRad)/2) < 0.1 ) then
					--	sdRad = sdRad + PI
					--	sdRad2 = sdRad2 + PI
					--end
					
					
					--prn('s:'  .. round2(sdRad,1) .. '   e:' .. round2(sdRad2,1) .. "   deg:" .. round2(tempPrnDeg,1))
					dirOfHook = GetDir( (sdRad2 + sdRad)/2) * TuneHLen
					 
					setTargetToCol  = vec2(dirOfHook.x, dirOfHook.y)
					 
					if(sc_ZeroHookVel == 0) then
						Game.Input.TargetX = dirOfHook.x
						Game.Input.TargetY = dirOfHook.y
					else 
					
					end
					
					break -- lenCheck for
				else 
					
				end
			end
		end
    end
	
	
	Fly()
	
	if(sc_SpinFire == 1 and Engine.Input:KeyIsPressed("mouse1")) then
		if(not Engine.Input:KeyIsPressed("mouse2")) then
			local testDir = normalize( vec2(math.sin(Game.Client.LocalTime*5 ), math.cos(Game.Client.LocalTime*5 ))) * 1000
			Game.Input.TargetX = testDir.x
			Game.Input.TargetY = testDir.y
			if(sc_FastFire == 0) then
				Game.Input.Fire = (Game.Input.Fire + 1) % 64
			end
		end
	end
	
	
	if(sc_Balance == 1) then
		if (sc_LastHookSelectedPlayerId ~= nil and sc_LastHookSelectedPlayerId >= 0) then 
			-- is anybody selected? Can we get to him?
			if(Game.Collision:IntersectLine(Game.LocalTee.Pos, Game.Players(sc_LastHookSelectedPlayerId).Tee.Pos, nil, nil, false) == 0) then				
				if(Game.LocalTee.Pos.x - Game.Players(sc_LastHookSelectedPlayerId).Tee.Pos.x > 2) then
					Game.Input.Direction = -1
				elseif(Game.Players(sc_LastHookSelectedPlayerId).Tee.Pos.x - Game.LocalTee.Pos.x > 2) then
					Game.Input.Direction = 1
				
				end
			end
			 
		end
		 
	end
	
	
	if(sc_StartRecord == 1) then
		sc_sendPlaybackCount = 1
		
				
		if(sc_AutoRestartRecordOnFail == 1 and #sc_playbackArray > 1) then
			if(restartRecordAtPos ~= nil) then
				if ( Game.Collision:Distance(Game.LocalTee.Pos, restartRecordAtPos) <= 0) then
					sc_playbackArray = {}
					Game.HUD:PushNotification('Automaticaly restarted record at fail', vec4(1,0,0,1))
					restartRecordAtPos = nil
				end
			else
				if ( Game.Collision:Distance(Game.LocalTee.Pos, vec2(sc_playbackArray[1].TeePosX, sc_playbackArray[1].TeePosY )) > 0) then
					restartRecordAtPos = vec2(sc_playbackArray[1].TeePosX, sc_playbackArray[1].TeePosY )
				end
			end
		end
 
 		_debugInfoStr = 'recframe: ' .. #sc_playbackArray 
		
		sc_playbackArray[#sc_playbackArray+1] = {
			Direction = Game.Input.Direction,
			Fire = Game.Input.Fire,
			Hook = Game.Input.Hook,
			Jump = Game.Input.Jump,
			--WantedWeapon  = Game.Input.WantedWeapon,
			WantedWeapon = Game.CharSnap(Game.LocalCID).Cur.Weapon, 
			TargetX  = Game.Input.TargetX,
			TargetY  = Game.Input.TargetY,
			TeePosX = Game.LocalTee.Pos.x,
			TeePosY = Game.LocalTee.Pos.y,
		}
		
	end
	--

	if(sc_StartRecord == 0 and Game.Client:DummyConnected() ) then
		if(sc_HammerHammerFly == 1) then
				local DummyTee = Game.Players(Game.DummyID).Tee
				
				local MainPos = Game.LocalTee.Pos
				local DummyPos = Game.Players(Game.DummyID).Tee.Pos
				if(Config.cl_dummy == 1 ) then
					DummyPos = Game.Players(Game.MainID).Tee.Pos
				end
				
				Game.Input.DummyWantedWeapon = WEAPON_HAMMER
				Game.Input.WantedWeapon = WEAPON_HAMMER
				
				 
				local mdDir = MainPos - DummyPos --dummy hit main
				local mDir = DummyPos - MainPos  --main hit dummy

				
				if( Game.LocalTee.HookState == HOOK_RETRACTED or ( Game.LocalTee.HookState == HOOK_GRABBED and
						(Game.LocalTee.HookedPlayer ~= Game.DummyID and Game.LocalTee.HookedPlayer ~= Game.LocalCID ) )) then
						Game.Input.Hook = 0
						
				elseif( DummyTee.HookState == HOOK_RETRACTED or ( DummyTee.HookState == HOOK_GRABBED and 
						(DummyTee.HookedPlayer ~= Game.DummyID and DummyTee.HookedPlayer ~= Game.LocalCID ) ) ) then

						Game.Input.DummyHook = 0
				elseif(Game.LocalTee.HookState ~= HOOK_GRABBED or DummyTee.HookState ~= HOOK_GRABBED) then
					
					
					
					Game.Input.DummyTargetX = mdDir.x
					Game.Input.DummyTargetY = mdDir.y
					
					Game.Input.TargetX = mDir.x
					Game.Input.TargetY = mDir.y
					
					Game.Input.DummyHook = 1
					Game.Input.Hook = 1


				end
				
				if(  Game.Collision:Distance(MainPos, DummyPos) <= 50) then
				--if(math.abs(DummyPos.y - MainPos.y ) < 32 and math.abs(DummyPos.x - MainPos.x) < 32+16 ) then
					
					if(( Game.LocalTee.HookState == HOOK_GRABBED and DummyTee.HookState == HOOK_GRABBED) and
						(Game.LocalTee.HookedPlayer == Game.DummyID and DummyTee.HookedPlayer == Game.LocalCID) ) then
							local fixedMDir = vec2(mDir.x, 0)
							local fixedMDDir = vec2(mdDir.x, 0)
							FireAtPos(mDir)
							DummyFireAtPos(mdDir)
					
					end
				--else
					--Game.Input.DummyHook = 0
				end
					
		 
			

		elseif(sc_dummy_copy == 1) then
			
			Game.Input.DummyDirection    = Game.Input.Direction     
			Game.Input.DummyFire         = Game.Input.Fire - lastInputData[Config.cl_dummy].Fire          
			Game.Input.DummyHook         = Game.Input.Hook          
			Game.Input.DummyJump         = Game.Input.Jump          
			Game.Input.DummyWantedWeapon = Game.Input.WantedWeapon - 1
			Game.Input.DummyTargetX      = Game.Input.TargetX       
			Game.Input.DummyTargetY      = Game.Input.TargetY       
			--Game.Input.DummyMouseX       = Game.Input.MouseX        
			--Game.Input.DummyMouseY       = Game.Input.MouseY        
			--Game.Input.DummyNextWeapon		= Game.Input.NextWeapon - lastInputData[Config.cl_dummy].NextWeapon
			--Game.Input.DummyPreviousWeapon	= Game.Input.PreviousWeapon - lastInputData[Config.cl_dummy].PreviousWeapon
			--flag copy missing
			if(sc_dummy_mirrorX == 1) then Game.Input.DummyTargetX = -Game.Input.DummyTargetX end
			if(sc_dummy_mirrorY == 1) then Game.Input.DummyTargetY = -Game.Input.DummyTargetY end
			if(sc_dummy_direction == 1) then Game.Input.DummyDirection = -Game.Input.DummyDirection end
			--m_InputData[g_Config.m_ClDummy].m_FCount - m_LastData[g_Config.m_ClDummy].m_FCount;
		end

	
	end
	
	lastInputData[Config.cl_dummy] = {
		Direction       = Game.Input.Direction, 
		Fire            = Game.Input.Fire, 
		Hook            = Game.Input.Hook, 
		Jump            = Game.Input.Jump, 
		WantedWeapon    = Game.Input.WantedWeapon, 
		TargetX         = Game.Input.TargetX, 
		TargetY         = Game.Input.TargetY, 
		MouseX          = Game.Input.MouseX, 
		MouseY          = Game.Input.MouseY, 
		Flags  			= Game.Input.Flags,
		NextWeapon		= Game.Input.NextWeapon,
		PreviousWeapon	= Game.Input.PreviousWeapon
	}
	
	
	
	lastInputData[1 - Config.cl_dummy] = {
		Direction       = Game.Input.DummyDirection, 
		Fire            = Game.Input.DummyFire, 
		Hook            = Game.Input.DummyHook, 
		Jump            = Game.Input.DummyJump, 
		WantedWeapon    = Game.Input.DummyWantedWeapon, 
		TargetX         = Game.Input.DummyTargetX, 
		TargetY         = Game.Input.DummyTargetY, 
		MouseX          = Game.Input.DummyMouseX, 
		MouseY          = Game.Input.DummyMouseY, 
		Flags  			= Game.Input.DummyFlags,
		NextWeapon		= Game.Input.DummyNextWeapon,
		PreviousWeapon	= Game.Input.DummyPreviousWeapon
	}
	

	
	return 
end

function OnKill(Sword, Shield, Weapon)
	if(sc_IsScriptEnabled ~= 1) then return end
	
	--Game.Players(Shield).Tee.Pos.x = 1000000
	--Game.Players(Shield).Tee.Pos.y = 1000000

	return 
end

function OnInputLevel(Level, KeyName, EventTable)
	--prn(KeyName .. '   ' .. Level .. '   ' )
	--return true
end




function RenderTest()
	--EnterFullscreen()
	
	--local Screen = Game.Ui:Screen()
	--Engine.Graphics:MapScreen(Screen.x, Screen.y, Screen.w, Screen.h)
	--Game.Ui:DoLabelScaled(UIRect(25, Screen.h/30 * 1, Screen.w, Screen.h/30),"XXXXXXXXXXXXX " ,17,0,Screen.w,"SS")
	--
end


function GlobalRender(Level)

	--local Screen = Game.Ui:Screen()
	--Engine.Graphics:MapScreen(Screen.x, Screen.y, Screen.w, Screen.h)
	--Game.Ui:DoLabelScaled(UIRect(25, Screen.h/30 * Level, Screen.w, Screen.h/30),"Level " .. Level,17,0,Screen.w,"SS")
	
end

--[[
0 CKillMessages      
1 CCamera            
2 CChat              
3 CMotd              
4 CBroadcast         
5 CGameConsole       
6 CBinds             
7 CParticles         
8 CMenus             
9 CMenusTooltip      
10 CSkins             
11 CCountryFlags      
12 CFlow              
13 CHud               
14 CDebugHud          
15 CControls          
16 CEffects           
17 CScoreboard        
18 CStatboard         
19 CSounds            
20 CEmoticon          
21 CDamageInd         
22 CVoting            
23 CSpectator         
24 CSpoofRemote       
25 CIdentity          
26 CGameTextureManager
27 CDrawing           
28 CFontMgr           
29 CFontMgr           
30 CSkinDownload   
 
]]--





RegisterEvent("OnKill", "OnKill")
RegisterEvent("OnEnterGame", "OnEnterGame")
RegisterEvent("OnChat", "OnChat")
RegisterEvent("OnConsoleCommand", "OnConsoleCommand")
RegisterEvent("OnKeyPress", "OnKeyPress")
RegisterEvent("OnSnapInput", "OnSnapInput")
RegisterEvent("OnKeyRelease", "OnKeyRelease")
RegisterEvent("OnRenderLevel14", "Render")
RegisterEvent("OnRenderLevel22", "RenderFullscreen")
--RegisterEvent("OnRenderLevel24", "RenderCustomMenu")
RegisterEvent("OnRenderLevel999", "RenderCustomMenu")


--RegisterEvent("OnRenderBackground", "OnRenderTest")



for i = 0, 30, 1 do -- find the top-most one
	if(i < 2 or i > 5) then 
		RegisterEvent("OnRenderLevel" .. i, function() GlobalRender(i) end)
	end
end

return 

--[[ENDOFFILE]]--
