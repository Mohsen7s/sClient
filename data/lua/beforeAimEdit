HOOK_RETRACTED=-1
HOOK_IDLE=0
HOOK_RETRACT_START=1
HOOK_RETRACT_END=3
HOOK_FLYING = 4
HOOK_GRABBED = 5
	


--[[
age agent asli bood file compile shode va xor shode ba crc32 ro befres age na ye file alaki befres
check kardane vers file exe ba lua va ekhtar daryaft file age ok nabood
auto exe updater
hardware unique identifier
disable other ONLINE bot immediately

]]--#


--[[#!
	#io
	#os
	#ffi
	#debug
	#package
]]--#


bitser = require 'bitser'
fs = require 'fs'

zip = require 'minizip'

BotRectArray = {}
BotRectArrayCount = 0

BotEditRectArray = {}
BotEditRectArrayCount = 0

availRecPosArray = {}


lastInputData = {}
lastInputData[0] = {
	Direction       = 0, 
	Fire            = 0, 
	Hook            = 0, 
	Jump            = 0, 
	WantedWeapon    = 0, 
	TargetX         = 0, 
	TargetY         = 0, 
	MouseX          = 0, 
	MouseY          = 0, 
	Flags 			= 0,
	NextWeapon		= 0,
	PreviousWeapon	= 0
}

lastInputData[1] = {
	Direction       = 0, 
	Fire            = 0, 
	Hook            = 0, 
	Jump            = 0, 
	WantedWeapon    = 0, 
	TargetX         = 0, 
	TargetY         = 0, 
	MouseX          = 0, 
	MouseY          = 0, 
	Flags 			= 0,
	NextWeapon		= 0,
	PreviousWeapon	= 0
}
	
function MakeAButton( BtnText, BtnRect, BtnTip, BtnAction, isChecked  )
	local ButtonData = {
		BC = NextBC(),
		Text = BtnText,
		Clicked = isChecked or false,
		Action = BtnAction,
		Rect = BtnRect,
		Tip = BtnTip
		
	}
	BotRectArrayCount = BotRectArrayCount + 1
	BotRectArray[BotRectArrayCount] = ButtonData
	
	 
end




function MakeATextBox( BtnText, BtnRect, BtnTip, BtnAction )
	local ButtonData = {
		EBC = NextEBC(),
		Text = BtnText,
		Clicked = false,
		Action = BtnAction,
		Rect = BtnRect,
		Tip = BtnTip
		
	}
	BotEditRectArrayCount = BotEditRectArrayCount + 1
	BotEditRectArray[BotEditRectArrayCount] = ButtonData
	
	 
end

function HandleMenuClicks()
	if( not sc_IsFullScreen) then return end
	for i = #BotRectArray, 1, -1 do -- find the top-most one
		if Game.Ui:MouseInside(BotRectArray[i].Rect) ~= 0 then
			BotRectArray[i].Action(BotRectArray[i])
		end
	end
	
end

SashBotVersion = 1.5


Import("config")
Import("containers")
_ConfigSet("Configed", SashBotVersion)

_ConfigLoad()


function OnScriptRenderSettings(MainView)
	local Button = UIRect(MainView.x, MainView.y, MainView.w, MainView.h)
	local Label = UIRect(MainView.x, MainView.y, MainView.w, MainView.h)

	MainView.HSplitTop(MainView, 20, Button, MainView)
	Button.VSplitLeft(Button, 250, Label, Button)
	Game.RenderTools:DrawUIRect(MainView, vec4f(0, 0, 0, 0.3), 15, 3)
	Game.Ui:DoLabelScaled(Label, "J : Jetpack Ride", 15, -1, -1, "")
	

	return 
end


SetScriptTitle("Sash Cheat")
SetScriptInfo("MultiCheats") -- $$ZZZ/ $$LLA![un]color <r> <g> <b> <name>



WantedPos = vec2f(0, 0)
MovePointPos = vec2f(0, 0)


g_ScriptTitle = "Aimbot By Sash"
g_ScriptInfo = "Sash Client"
INF = 1000000
Vic = -1
Error = 45
PI = 3.14159265359
UseBL = 0
BL = {}

Tut = -1
UseDD = 0
Gup = 0
TeeRadConst = 20 --20
TeeTall = 42  --42
ConLoc = 0
ConEn = 2.4 --1.4
Shutup = 0
Con = 0.001
UseG = 0
Focus = 0
LimitR = 168100



STATE_ONLINE = 3




tickCountOfPlayerHook = 0
hook_length = Game:Tuning().hook_length:Get()
laser_reach = Game:Tuning().laser_reach:Get()
laser_bounce_num = Game:Tuning().laser_bounce_num:Get()
--sc Sash Config


sc_dummy_copy = 0
sc_dummy_mirrorX = 0
sc_dummy_mirrorY = 0
sc_dummy_direction = 0

sc_AutoHammerFly = 0

sc_AutoAimHook = 1
sc_AutoAimFire = 1

sc_PlaybackBot = 1
sc_HookrideBot = 1
sc_JetrideBot = 1


sc_FastFire = 0
sc_FastHook = 0
sc_HookCol = 0

sc_Balance = 0
sc_IsScriptEnabled = 1
sc_TempTest = 0
sc_ZeroHookVel = 0
sc_JetpackRide = 0
sc_SpinFire = 0
sc_AimAccuracy = 0.25
sc_DummyHookFly = 0


sc_LastHookSelectedPlayerId = -1
lastHookAimPos = vec2(0, 0)
lastHookAimId = -1

sc_IsFullScreen = false


--sc_fh_ sash client fast hook
sc_fh_hookTimer = -1
sc_fh_rehookTestCount = 0
sc_fh_minimumRehookFoundCount = 50
sc_fh_maxHookTime = 61 --100
sc_fh_rehookAtTime = 10

const_degInRad = 0.0174533


function CalcPos(Pos, Velocity, Curvature, Speed, Time)
	local n = vec2(0,0)
	Time = Time * Speed
	n = vec2(Pos.x + Velocity.x*Time, Pos.y + Velocity.y*Time + Curvature/10000*(Time*Time))
	return n
end


function GetLaserLines(StartPos, HeadVector, TravelDist, bounceCount, fromLine)
	 
	Lines = {}

	distanceTravel = TravelDist 
	local nDir = normalize(HeadVector) * distanceTravel
	LastLinePos = StartPos
	 
	for it = 0, bounceCount, 1 do
		local colPos = vec2(0,0)
		local beforeColPos = vec2(0,0)
		local nres = vec2(LastLinePos.x + nDir.x, LastLinePos.y + nDir.y)
		
		if(Game.Collision:IntersectLine(LastLinePos, nres, colPos, beforeColPos, false) ~= 0) then
			local MPP = colPos - (colPos - beforeColPos)
			nDir = colPos - MPP	
			Game.Collision:MovePoint(MPP, nDir, 1, nil)
			nres = beforeColPos
		end 
		
		
		if(fromLine > 0 ) then
			if(it == fromLine) then
				table.insert(Lines, LineItem(LastLinePos.x, LastLinePos.y, nres.x, nres.y))
				break
			end
		else
			table.insert(Lines, LineItem(LastLinePos.x, LastLinePos.y, nres.x, nres.y))
		end
		
		local traveledDist = Game.Collision:Distance(LastLinePos, nres)
		if(traveledDist == 0) then break end
		distanceTravel = distanceTravel - traveledDist
		nDir = normalize(nDir) * distanceTravel
		LastLinePos = nres
		if(distanceTravel <= 0) then break end
		
	end
	
	return Lines
				
end

function GetWeaponPos(Weapon, Time, m_Direction)
	--need to check if we are inside a tunezone... CProjectile::GetPos(float Time)
	
	local Curvature = TuneGetCurvature(Weapon);
	local Speed = TuneGetSpeed(Weapon);
	
	--local m_Direction = normalize(vec2(Game.Input.MouseX, Game.Input.MouseY))

	local retRes = CalcPos(Game.LocalTee.Pos, m_Direction, Curvature, Speed, Time)
	
	if(Weapon == WEAPON_GRENADE) then
		retRes = vec2(retRes.x, retRes.y - 16)
	end
	
	return retRes
	
end


 
function bearing(a1, a2, b1, b2) 
	local TWOPI = 6.2831853071795865
	local RAD2DEG = 57.2957795130823209
	--if (a1 = b1 and a2 = b2) throw an error 
	
	local theta = math.atan2(b1 - a1, a2 - b2)
	if (theta < 0.0) then theta = theta + TWOPI end
	local degRes =  (RAD2DEG * theta) + 90
	if(degRes >= 360) then degRes = degRes - 360 end
	
	return degRes
	
end



function normalize(inVec2)
	local l = 1 / math.sqrt(inVec2.x * inVec2.x + inVec2.y * inVec2.y)
	return vec2(inVec2.x * l, inVec2.y * l)
end

function GetDir(a)
    return vec2f(math.cos(a), math.sin(a))
end

function HeadVectorToRadian(x, y)
	return math.atan2(y, x)
end


function GetWeaponLine(Weapon, inPlayerId)
	--Game.VClient(inPlayerId).TargetX

	Lines = {}
	
	if(Weapon ~= WEAPON_RIFLE) then
		nDir = normalize(vec2(Game.Input.MouseX, Game.Input.MouseY))
		LastLinePos = GetWeaponPos(Weapon, 0, nDir )
		local Lifetime = TuneGetLifetime(Weapon)
		for it = 0, Lifetime, 0.02 do
			local nres = GetWeaponPos(Weapon, it, nDir )
			table.insert(Lines, LineItem(LastLinePos.x, LastLinePos.y, nres.x, nres.y))
			LastLinePos = nres
			if(Game.Collision:IntersectLine(LastLinePos, nres, nil, nil, false) ~= 0) then
				break
			end
		end
	elseif(Weapon == WEAPON_RIFLE) then
		--local we = bearing(Game.LocalTee.Pos.x, Game.LocalTee.Pos.y, Game.Input.MouseX, Game.Input.MouseY)
		--_debugInfoStr = "we" .. we

		local tempHeadVector = vec2(Game.Input.MouseX, Game.Input.MouseY)
		
		Lines = GetLaserLines(Game.LocalTee.Pos + (normalize(tempHeadVector) * 28) , vec2(Game.Input.MouseX, Game.Input.MouseY), laser_reach - 28, laser_bounce_num, 0)
				
	end
	
	
	return Lines
end



 

function OnTick()
	if(sc_IsScriptEnabled ~= 1) then return end
	--if(Config.cl_overlay_entities == 0) then Config.cl_overlay_entities = 100 end

	
	if(Game.Input.Hook == 1) then
		sc_LastHookSelectedPlayerId = Game.LocalTee.HookedPlayer
	end
	 
	if(Game.Client.State ~= STATE_ONLINE) then return end
 
	  
end

function Posx(id)
	if Game.Players(id).Tee.Vel.x < 5 then
		return Game.Players(id).Tee.Pos.x
	end

	return Game.Players(id).Tee.Pos.x + Game.Players(id).Tee.Vel.x*ConEn
end

function Posy(id)
	if Game.Players(id).Tee.Vel.y < 5 then
		return Game.Players(id).Tee.Pos.y
	end

	return Game.Players(id).Tee.Pos.y + Game.Players(id).Tee.Vel.y*ConEn
end

function LPosx()
	if Game.LocalTee.Vel.x < 5 then
		return Game.LocalTee.Pos.x
	end

	return Game.LocalTee.Pos.x + Game.LocalTee.Vel.x*ConLoc
end

function LPosy()
	if Game.LocalTee.Vel.y < 5 then
		return Game.LocalTee.Pos.y
	end

	return Game.LocalTee.Pos.y + Game.LocalTee.Vel.y*ConLoc
end


function degDiffSigned(deg1, deg2)
	local a = deg1 - deg2
	return (a + 180) % 360 - 180
end

function degDiff(deg1, deg2)
	return math.abs(degDiffSigned(deg1, deg2))
end

function Grab()
	lastHookAimPos = vec2(0, 0)
	lastHookAimId = -1

	local mn = INF
	local Target = -1

	for i = 0, 64, 1 do
 
		if Game.Players(i).Active and i ~= Game.LocalCID and Game.CharSnap(i).Active then
			
		
			local rxx = LPosx() - Posx(i)
			local ryy = LPosy() - Posy(i)

			if rxx*rxx + ryy*ryy <= LimitR then
				local isgo = 1

				if UseBL == 1 and BL[i] == 0 then
					isgo = 0
				end

				if isgo == 1 and 0 < SetAim(i, 0) + UseDD then
					local we = Dif(Game.Input.MouseX, Game.Input.MouseY, Posx(i) - LPosx(), Posy(i) - LPosy())
					
					if (we < mn and UseBL == 0) or (we < mn and UseBL == 1 and BL[i] == 1) then
						mn = we
						if mn <= Error then
							lastHookAimPos = vec2(Posx(i), Posy(i))
							lastHookAimId = i
							Target = i
						end
					end
				end
			end
		end
	end

	return Target
end

function Deg(x, y)
	local res = math.deg(math.atan(x/y))

	if y < 0 then
		res = res + 90
	end

	if 0 <= y then
		res = res + 270
	end

	return res
end

function Dif(x, y, xx, yy)
	local resa = Deg(x, y)
	local resb = Deg(xx, yy)
	local res = math.abs(resa - resb)

	if 360 - res < res then
		res = 360 - res
	end

	return res
end

function Police(Name)
	for i = 0, 64, 1 do
		if Game.Players(i).Name == Name then
			return i
		end
	end

	return -1
end



function resetTeeHookBL()
	for i = 0, 64, 1 do
		BL[i] = 0
		
	end
end

function resetAvailableRecord()
	availRecPosArray = {}
	local recPath = 'rec/' .. encodeString(Game.ServerInfo.Map)
	if( not Game.Players(Game.LocalCID).Active ) then return end
	for name, d in fs.dir(recPath) do
		if not name then
		  break
		end
		--local decStr = 
		local decCnt = 1
		local decX = ""
		local decY = ""
		local recorder = ""
		local dateTime = ""
		local desc1 = ""
		local desc2 = ""
		local desc3 = ""


		for w in decodeString( name):gmatch("([^_]+)") do 
			if(decCnt == 1) then recorder = w end
			if(decCnt == 2) then decX = w end
			if(decCnt == 3) then decY = w end
			if(decCnt == 4) then dateTime = w end
			if(decCnt == 5) then dateTime = dateTime .. ' ' .. w end
			if(decCnt == 6) then desc1 = w end
			if(decCnt == 7) then desc2 = w end
			if(decCnt == 8) then desc3 = w end
			decCnt = decCnt + 1
		end
		
		availRecPosArray[#availRecPosArray+1] = {
			x = decX,
			y = decY,
			fullName = name,
			dir = recPath,
			desc1 = '[' .. dateTime .. '] ' .. recorder,
			desc2 = desc1 .. ' ' .. desc2 .. ' ' .. desc3 .. ' '
		}
 
	end
end

function OnEnterGame()
	if(sc_IsScriptEnabled ~= 1) then return end
	resetTeeHookBL()
	 
	local recPath = 'rec/' .. encodeString(Game.ServerInfo.Map)
	fs.mkdir(recPath, true)
	
	resetAvailableRecord()
	
	 

	
	return 
end

function OnChat(ID, Team, Msg)
	if(sc_IsScriptEnabled ~= 1) then return end
	
	if ID ~= Game.LocalCID then
		return 
	end 
	
end

function OnConsoleCommand(Msg)

	if Msg.find(Msg, "!len") then
		local Name = Msg.gsub(Msg, "!len ", "")
		Error = tonumber(Name)
	end
	
	if Msg.find(Msg, "!aimacc") then
		local Name = Msg.gsub(Msg, "!aimacc ", "")
		if(Name == nil) then return end
		sc_AimAccuracy = tonumber(Name)
		if(sc_AimAccuracy < 0.25) then sc_AimAccuracy = 0.25 end
	end
	
	


	if Msg.find(Msg, "!canon") then
		local Name = Msg.gsub(Msg, "!canon ", "")
		Con = tonumber(Name)/100000
	end

	if Msg.find(Msg, "!lock") then
		local Name = Msg.gsub(Msg, "!lock ", "")
		local inv = Police(Name)

		if inv == -1 and Name == "disable" then
			UseBL = 0

			resetTeeHookBL()
		end

		if inv ~= -1 then
			BL[inv] = 1
			UseBL = 1
		end
	end

	if Msg.find(Msg, "!unlock") then
		local Name = Msg.gsub(Msg, "!unlock ", "")
		local inv = Police(Name)

		if inv == -1 and Name == "disable" then
			UseBL = 0

			resetTeeHookBL()
		end

		if inv ~= -1 then
			BL[inv] = 0
		end
	end

	if Msg.find(Msg, "!ddrace") then
		UseDD = 1 - UseDD
		ConEn = 2.3
	end

	if Msg.find(Msg, "!grenade") then
		UseG = 1 - UseG
	end



	if Msg.find(Msg, "!temptest") then
		sc_TempTest = 1 - sc_TempTest
	end
	
	
	return 
end

function Dis(x, y, xx, yy)
	local res = 0
	res = res + (x - xx)*(x - xx)
	res = res + (y - yy)*(y - yy)
	res = math.sqrt(res)

	return res
end


 
function intersection (s1, e1, s2, e2)
    local a1 = e1.y - s1.y;
    local b1 = s1.x - e1.x;
    local c1 = a1 * s1.x + b1 * s1.y;
     
    local a2 = e2.y - s2.y;
    local b2 = s2.x - e2.x;
    local c2 = a2 * s2.x + b2 * s2.y;
     
    local delta = a1 * b2 - a2 * b1;
	return delta
		
end
 


function doLinesIntersect( a, b, c, d )
    -- parameter conversion
    local L1 = {X1=a.x,Y1=a.y,X2=b.x,Y2=b.y}
    local L2 = {X1=c.x,Y1=c.y,X2=d.x,Y2=d.y}

    -- Denominator for ua and ub are the same, so store this calculation
    local _d = (L2.Y2 - L2.Y1) * (L1.X2 - L1.X1) - (L2.X2 - L2.X1) * (L1.Y2 - L1.Y1)

    -- Make sure there is not a division by zero - this also indicates that the lines are parallel.
    -- If n_a and n_b were both equal to zero the lines would be on top of each
    -- other (coincidental).  This check is not done because it is not
    -- necessary for this implementation (the parallel check accounts for this).
    if (_d == 0) then
        return false
    end

    -- n_a and n_b are calculated as seperate values for readability
    local n_a = (L2.X2 - L2.X1) * (L1.Y1 - L2.Y1) - (L2.Y2 - L2.Y1) * (L1.X1 - L2.X1)
    local n_b = (L1.X2 - L1.X1) * (L1.Y1 - L2.Y1) - (L1.Y2 - L1.Y1) * (L1.X1 - L2.X1)

    -- Calculate the intermediate fractional point that the lines potentially intersect.
    local ua = n_a / _d
    local ub = n_b / _d

    -- The fractional point will be between 0 and 1 inclusive if the lines
    -- intersect.  If the fractional calculation is larger than 1 or smaller
    -- than 0 the lines would need to be longer to intersect.
    if (ua >= 0 and ua <= 1 and ub >= 0 and ub <= 1) then
        local x = L1.X1 + (ua * (L1.X2 - L1.X1))
        local y = L1.Y1 + (ua * (L1.Y2 - L1.Y1))
        return {x=x, y=y}
    end

    return false
end

			
--function intersection (s1, e1, s2, e2)
--  local d = (s1.x - e1.x) * (s2.y - e2.y) - (s1.y - e1.y) * (s2.x - e2.x)
--  local a = s1.x * e1.y - s1.y * e1.x
--  local b = s2.x * e2.y - s2.y * e2.x
--  local x = (a * (s2.x - e2.x) - (s1.x - e1.x) * b) / d
--  local y = (a * (s2.y - e2.y) - (s1.y - e1.y) * b) / d
--  return x, y
--end
 



function PreRenderPlayer(ID, PosX, PosY, DirX, DirY, OtherTeam)


	


end

XYLaser = nil




function PostRenderPlayer(ID, PosX, PosY, DirX, DirY, OtherTeam)

	XYLaser = nil

 
 
	--_debugInfoStr = "vx:" .. round2(Game.Players(0).Tee.Vel.x) .. "     vy:" .. round2(Game.Players(0).Tee.Vel.y)
	
	local HookPercent= sc_fh_hookTimer * 100 / sc_fh_maxHookTime
	if(ID == Game.LocalCID and Game.LocalTee.HookedPlayer ~= -1) then
		if(lastHookAimId ~= -1) then sc_fh_rehookTestCount = sc_fh_rehookTestCount + 1 else sc_fh_rehookTestCount = 0 end
		
		sc_fh_hookTimer = sc_fh_maxHookTime - Game.LocalTee.HookTick
		
		if(sc_FastHook == 1 and sc_fh_hookTimer < sc_fh_rehookAtTime and Game.LocalTee.HookedPlayer == lastHookAimId and sc_fh_rehookTestCount > sc_fh_minimumRehookFoundCount) then
			Game.Input.Hook = 0
		end
		
		local PerHUD = UIRect(PosX-50, PosY-50, 100 , 20)
		Game.RenderTools:DrawUIRect(PerHUD, vec4f(0,0,0, 1),  _CUI.CORNER_ALL, 0)
		
		local PerLine = UIRect(PosX-50, PosY-50, HookPercent , 20)
		Game.RenderTools:DrawUIRect(PerLine, vec4f(255,255,255, 1),  _CUI.CORNER_ALL, 0)
		
		
		
	end 
	
	
		
			
		Lines = GetWeaponLine(Game.CharSnap(ID).Cur.Weapon)
		--Lines = GetWeaponLine(WEAPON_RIFLE)
		
		if (#Lines > 0) then
			Engine.Graphics:TextureSet(-1)
			Engine.Graphics:LinesBegin()
				Engine.Graphics:SetColor(1, 0, 0, 1)
				Engine.Graphics:LinesDraw(Lines)
			Engine.Graphics:LinesEnd()
		end


	
	if(ID == Game.LocalCID) then
		
		
		Engine.Graphics:TextureSet(-1)
		Engine.Graphics:QuadsBegin()
			Engine.Graphics:SetColor(0,1,1, 1)
			Game.RenderTools:DrawCircle(MovePointPos.x, MovePointPos.y, 30, 30)
		Engine.Graphics:QuadsEnd()
	
		
		
		Engine.Graphics:TextureSet(-1)
		Engine.Graphics:QuadsBegin()
			Engine.Graphics:SetColor(1,0,0, 1)
			Game.RenderTools:DrawCircle(WantedPos.x, WantedPos.y, 10, 10)
		Engine.Graphics:QuadsEnd()
	
	
		Engine.Graphics:TextureSet(-1)
		Engine.Graphics:QuadsBegin()
			Engine.Graphics:SetColor(255,255,255, 0.2)
			Game.RenderTools:DrawCircle(PosX, PosY, hook_length, 40)
		Engine.Graphics:QuadsEnd()
		
		
		
		for i=1,#availRecPosArray,1 do
			--check only render if its near the tee
			local val = i / #availRecPosArray
			local Rect = UIRect(availRecPosArray[i].x-25, availRecPosArray[i].y-25, 50, 50)
			--Game.RenderTools:DrawUIRect(Rect, vec4f(0,1,1, 0.75), _CUI.CORNER_ALL, 15+10*math.sin(Game.Client.LocalTime *math.pi))	
			local dirToMe = normalize( Game.LocalTee.Pos - vec2(availRecPosArray[i].x, availRecPosArray[i].y))
			--DrawTee(Rect, Game.LocalCID, 80, dirToMe)
			DrawLocalPlaybackTee(Rect, dirToMe)
			
			
			Engine.TextRender:TextColor(1,0,0,1)
			Engine.TextRender:Text(nil, availRecPosArray[i].x-75, availRecPosArray[i].y-55, 12,availRecPosArray[i].desc1,-1)
			Engine.TextRender:TextColor(0,1,0,1)
			Engine.TextRender:Text(nil, availRecPosArray[i].x-75, availRecPosArray[i].y-40, 12,availRecPosArray[i].desc2,-1)
			Engine.TextRender:TextColor(1,1,1,1)
			
			 
		end
		

		
		 
		-- other tee velocities
		LinesTee = {}  
		for i = 0, 64, 1 do
	 
			if Game.Players(i).Active  and Game.CharSnap(i).Active then
				local velPos = Game.Players(i).Tee.Pos + (Game.Players(i).Tee.Vel * 10)
				table.insert(LinesTee, LineItem(Game.Players(i).Tee.Pos.x, Game.Players(i).Tee.Pos.y, velPos.x, velPos.y))
 
			 
			end
		end 
		if (#LinesTee > 0) then
			Engine.Graphics:TextureSet(-1)
			Engine.Graphics:LinesBegin()
				Engine.Graphics:SetColor(1, 1, 0, 1)
				Engine.Graphics:LinesDraw(LinesTee)
			Engine.Graphics:LinesEnd()
		end
		
	end
	if(ID == lastHookAimId) then
		
		Engine.Graphics:TextureSet(-1)
		Engine.Graphics:QuadsBegin()
			Engine.Graphics:SetColor(0, 255, 0, 0.5)
			Game.RenderTools:DrawCircle(PosX, PosY, 28, 32)
		Engine.Graphics:QuadsEnd()

	end

end




function OnEnterFullscreen()
	sc_IsFullScreen = true
	
	

end

function OnExitFullscreen()
	sc_IsFullScreen = false
	

end



function RenderFullscreen()
	if(sc_IsFullScreen) then
	
	local Screen = Game.Ui:Screen()
	Engine.Graphics:MapScreen(Screen.x, Screen.y, Screen.w, Screen.h)

	--local BtnRect = UIRect(100,100,100,25)
	
	

		
		
	--local Rect = UIRect(0, 0, Screen.w, Screen.h)
	Game.RenderTools:DrawUIRect(Screen, vec4f(0,0,0,0.8), _CUI.CORNER_ALL, 10)
	Game.RenderTools:DrawUIRect(RectV11, vec4f(0,1,1,0.5), _CUI.CORNER_ALL, 10)
	Game.RenderTools:DrawUIRect(RectV12, vec4f(0,1,1,0.5), _CUI.CORNER_ALL, 10)
	Game.RenderTools:DrawUIRect(RectV21, vec4f(0,1,1,0.5), _CUI.CORNER_ALL, 10)
	Game.RenderTools:DrawUIRect(RectV22, vec4f(0,1,1,0.5), _CUI.CORNER_ALL, 10)
    
		
		
	--prn('i:  ' .. #BotRectArray)
	for i = #BotRectArray, 1, -1 do -- find the top-most one
		--Game.Menus:DoButton_CheckBox(BotRectArray[i].BC, BotRectArray[i].Text, 1, BotRectArray[i].Rect, "Tooltip", _CUI.CORNER_ALL)
		--Game.Menus:DoButton_CheckBox(BotRectArray[i].BC, BotRectArray[i].Text, 1, BotRectArray[i].Rect, "Tooltip", _CUI.CORNER_ALL)
		--Game.Menus:DoButton_Toggle(BotRectArray[i].BC, 0, BotRectArray[i].Rect, 0, "Tooltip")
		--Game.Menus:DoButton_Menu(BotRectArray[i].BC, BotRectArray[i].Text, 1, BotRectArray[i].Rect, "Tooltip", _CUI.CORNER_ALL, vec4(0,1,0,0.5))
		--Game.Menus:DoColorPicker(NextBC(), NextBC(), UIRect(100,100,400,400), vec3(0.5,0.5,1))

		
		--Game.Menus:DoEditbox(BotEditRectArray[i].EBC, BotEditRectArray[i].Rect, 13, true, _CUI.CORNER_ALL, "Emtext", "Tooltip")

		if(BotRectArray[i].Clicked) then
			Game.Menus:DoButton_CheckBox(BotRectArray[i].BC, BotRectArray[i].Text, 1, BotRectArray[i].Rect, BotRectArray[i].Tip, _CUI.CORNER_ALL)
		else
			Game.Menus:DoButton_CheckBox(BotRectArray[i].BC, BotRectArray[i].Text, 0, BotRectArray[i].Rect, BotRectArray[i].Tip, _CUI.CORNER_ALL)
		end
		--prn('i:  ' .. BotRectArray[i].Text)
	end	
	
	--check if nmouse clicked and edit it!
	--if Game.Ui:MouseInside(ButtonData.Rect) ~= 0 then
	--	 
	--end 
	
		
		--MyEBC = NextBC()
		--Game.Menus:DoButton_Menu(MyEBC, "som text", 1, BtnRect, "tooltip text", _CUI.CORNER_ALL, vec4(1,1,1,0.5))
		----check if nmouse clicked and edit it!
		--if Game.Ui:MouseInside(BtnRect) ~= 0 then
		--	Engine.Graphics:TextureSet(BlueTex)
		--	Engine.Graphics:QuadsBegin()
		--		Game.RenderTools:SelectSprite(SPRITE_HEALTH_FULL,0,0,0)
		--		Game.RenderTools:DrawSprite(50, 50,100)
		--	Engine.Graphics:QuadsEnd()
		--end
		
		 

		




		Game.Ui:DoLabelScaled(UIRect(Screen.w/2, Screen.h/2,100,50),"You can access this in next release",17,0,500,nil)

	end
	-- rect at cursor for debugging mouse pos
	--local Rect = UIRect(Game.Menus.MousePos.x-24/2, Game.Menus.MousePos.y-24/2, 24, 24)
	--Game.RenderTools:DrawUIRect(Rect, vec4f(1,0,1,1), 0, 0)
end


function MakeSimpleCheckBox(LastRectPos, Text, ToolTip, DoAction, isChecked)
	
	local RectBotOptionsT1 = UIRect(0,0,0,0)
	LastRectPos:HSplitTop(25,RectBotOptionsT1, LastRectPos) 
	MakeAButton( Text, RectBotOptionsT1, ToolTip, function(BtnInfo)
		BtnInfo.Clicked = not BtnInfo.Clicked
		DoAction()
	end, isChecked or false )
	

end

function CalcRects()

	local Screen = Game.Ui:Screen()
	RectV1 = UIRect(0,0,0,0)
	RectV2 = UIRect(0,0,0,0)
	  
	RectV11 = UIRect(0,0,0,0)
	RectV12 = UIRect(0,0,0,0)
	  
	RectV21 = UIRect(0,0,0,0)
	RectV22 = UIRect(0,0,0,0)

	Screen:VSplitRight(Screen.w/2, RectV1, RectV2)
	RectV1:VSplitRight(RectV1.w/2, RectV11, RectV12)
	RectV2:VSplitRight(RectV2.w/2, RectV21, RectV22)
	
	RectV11:VMargin(10,RectV11) 
	RectV12:VMargin(10,RectV12) 
	RectV21:VMargin(10,RectV21) 
	RectV22:VMargin(10,RectV22) 
 

	
	RectBotOptionsB = RectV11:copy()

	--Config.cl_dummy_copy_moves = 0
	--Config.cl_dummy_copy_mirror = 0

 
	MakeSimpleCheckBox(RectBotOptionsB, "Auto Aim Hook", "T1", function() sc_AutoAimHook = 1 - sc_AutoAimHook end, true)
	MakeSimpleCheckBox(RectBotOptionsB, "Auto Aim Fire", "T1", function() sc_AutoAimFire = 1 - sc_AutoAimFire end, true)
	MakeSimpleCheckBox(RectBotOptionsB, "Spin Fire", "T1", function() sc_SpinFire = 1 - sc_SpinFire end)


	MakeSimpleCheckBox(RectBotOptionsB, "Fast Fire", "T1", function() sc_FastFire = 1 - sc_FastFire end)
	MakeSimpleCheckBox(RectBotOptionsB, "Fast Hook", "T1", function() sc_FastHook = 1 - sc_FastHook end)
	MakeSimpleCheckBox(RectBotOptionsB, "Hook Nearest Collision", "T1", function() sc_HookCol = 1 - sc_HookCol end)
	
	
	MakeSimpleCheckBox(RectBotOptionsB, "Auto Dummy Hammer Fly", "T1", function()
		sc_AutoHammerFly = 1 - sc_AutoHammerFly
		Config.cl_dummy_hammer = sc_AutoHammerFly
	end)
	MakeSimpleCheckBox(RectBotOptionsB, "Auto Dummy Hook Fly", "T1", function() sc_DummyHookFly = 1 - sc_DummyHookFly end)
	--MakeSimpleCheckBox(RectBotOptionsB, "Copy Dummy", "T1", function() Config.cl_dummy_copy_moves = 1 - Config.cl_dummy_copy_moves end)
	MakeSimpleCheckBox(RectBotOptionsB, "Copy Dummy", "T1", function() sc_dummy_copy = 1 - sc_dummy_copy end)
	MakeSimpleCheckBox(RectBotOptionsB, "Reverse Copy X/Axis", "T1", function() sc_dummy_mirrorX = 1 - sc_dummy_mirrorX end)
	MakeSimpleCheckBox(RectBotOptionsB, "Reverse Copy Y/Axis", "T1", function() sc_dummy_mirrorY = 1 - sc_dummy_mirrorY end)
	MakeSimpleCheckBox(RectBotOptionsB, "Reverse Copy Direction", "T1", function() sc_dummy_direction = 1 - sc_dummy_direction end)
	
	--MakeSimpleCheckBox(RectBotOptionsB, "Reverse Copy Dummy", "T1", function() Config.cl_dummy_copy_mirror = 1 - Config.cl_dummy_copy_mirror end)
	MakeSimpleCheckBox(RectBotOptionsB, "Balance On Hooked Tee", "T1", function() sc_Balance = 1 - sc_Balance end)
	
	MakeSimpleCheckBox(RectBotOptionsB, "Allow play or record playback", "CTRL + Mouse Middle Button[CTRL+ALT+SHIFT+MOUSE MIDDLE = DELETE record!]", function() sc_StartRecord = 0 sc_PlaybackBot = 1 - sc_PlaybackBot end, true)
	MakeSimpleCheckBox(RectBotOptionsB, "Allow Hookride Bot", "ALT + Mouse Right Button", function() sc_ZeroHookVel = 0 sc_HookrideBot = 1 - sc_HookrideBot end, true)
	MakeSimpleCheckBox(RectBotOptionsB, "Allow Jetride Bot", "ALT + Mouse Left Button", function() sc_JetpackRide = 0 sc_JetrideBot = 1 - sc_JetrideBot end, true)
	
	
	
 
	 
end


function OnScriptUnload()

	Engine.Graphics:UnloadTexture(BlueTex) 
end

function OnScriptInit()

	ContainersStart()
	if(_ConfigGet("Configed") ~= SashBotVersion) then
		prn('First Automatic Config!')
		_ConfigSet("Configed", SashBotVersion)
		_ConfigSet("JetRideKey", "mouse1")
		_ConfigSet("HookRideKey", "mouse2")
		_ConfigSet("BalanceKey", "b")
		
		_ConfigSave()
		_ConfigLoad()
	end
	 
	NeonTeeTex = Engine.Graphics:LoadTexture("data/skins/Neontee.png",-1,-1,1)
	BlueTex = Engine.Graphics:LoadTexture("data/textures/game/blue.png",-1,-1,1)

	
	--if(BotRectArray == nil) then BotRectArray = {} end

	CalcRects()
		
	--local BtnRect = UIRect(100,100,100,25)
	--MakeAButton( "som text", BtnRect, "ATTip", function(BtnInfo) BtnInfo.Clicked = not BtnInfo.Clicked end  )
	--MakeATextBox( "som text", BtnRect, "ATTip", function(BtnInfo) BtnInfo.Clicked = not BtnInfo.Clicked end  )
	
	
	local ret = true
	--Tex = Engine.Graphics:LoadTexture("data/textures/game/".. Config.tex_game ..".png",-1,-1,1)
	if 
		Import("algorithm") and
		Import("broadcast") and
		--Import("config") and		
		Import("debug") and
		Import("general") and
		Import("logger") and
		Import("luac") and
		Import("math") and
		--Import("queue") and
		Import("sound") and
		Import("sprites") and
		Import("stringutils") and
		Import("tune") and
		Import("twdata") and
		Import("twutils") and
		Import("types") and
		Import("ui") then
		ret = true
	else
		ret = false
	end
	
	
	resetAvailableRecord()
	
	return ret
end

function scHudDrawProperty(txt, prop, x, y, fontSize)
	if(prop == 1) then Engine.TextRender:TextColor(0,1,0,1) else Engine.TextRender:TextColor(1,0,0,1) end
	Engine.TextRender:Text(nil, x, y, fontSize,txt,-1)
	Engine.TextRender:TextColor(1,1,1,1)
	return Engine.TextRender:TextWidth(nil,fontSize,txt,-1,-1) + 10
end

_debugInfoStr = ""

function DrawLocalPlaybackTee(RectPos, inDir)

 	local MyTee = TeeRenderInfo() -- Ohne parameter???
	MyTee.Texture = NeonTeeTex
	--MyTee.ColorBody = Game.Players(Game.LocalCID).RenderInfo.ColorBody
	--MyTee.ColorFeet = Game.Players(Game.LocalCID).RenderInfo.ColorFeet
	MyTee.Size = 80
	MyTee.GotAirJump = 1
	--if(inDir == nil) then
	--	inDir = vec2(math.cos(Game.Client.LocalTime * 5), math.sin(Game.Client.LocalTime * 5))
	--end
	
	--Game.RenderTools:RenderTee( Game.CharSnap(DisplayID).Cur.Emote , MyTee , vec2f(math.cos(Game.Client.LocalTime * 5), math.sin(Game.Client.LocalTime * 5)) , vec2f(TeeWindow.x+TeeWindow.w/2,TeeWindow.y+TeeWindow.h/2),false,0)
	Game.RenderTools:RenderTee( Game.CharSnap(Game.LocalCID).Cur.Emote , MyTee , vec2f(inDir.x, inDir.y) , vec2f(RectPos.x+RectPos.w/2,RectPos.y+RectPos.h/2),false,0)

end

function DrawTee(TeeWindow,DisplayID,Size, inDir)
	-- Draw name at the Top

 	local MyTee = TeeRenderInfo() -- Ohne parameter???
	MyTee.Texture = Game.Players(DisplayID).RenderInfo.Texture
	MyTee.ColorBody = Game.Players(DisplayID).RenderInfo.ColorBody
	MyTee.ColorFeet = Game.Players(DisplayID).RenderInfo.ColorFeet
	MyTee.Size = Size or 80 --Game.Players(DisplayID).RenderInfo.Size
	MyTee.GotAirJump = Game.Players(DisplayID).RenderInfo.GotAirJump
	if(inDir == nil) then
		inDir = vec2(math.cos(Game.Client.LocalTime * 5), math.sin(Game.Client.LocalTime * 5))
	end
	--Game.RenderTools:RenderTee( Game.CharSnap(DisplayID).Cur.Emote , MyTee , vec2f(math.cos(Game.Client.LocalTime * 5), math.sin(Game.Client.LocalTime * 5)) , vec2f(TeeWindow.x+TeeWindow.w/2,TeeWindow.y+TeeWindow.h/2),false,0)
	Game.RenderTools:RenderTee( Game.CharSnap(DisplayID).Cur.Emote , MyTee , vec2f(inDir.x, inDir.y) , vec2f(TeeWindow.x+TeeWindow.w/2,TeeWindow.y+TeeWindow.h/2),false,0)
end


function Render()
	--if(sc_IsScriptEnabled ~= 1) then return end
	
	local MainView = Game.Ui:Screen()
	Engine.Graphics:MapScreen(0,0, MainView.w, MainView.h)

	
	Label = UIRect(Game.LocalTee.Pos.x, Game.LocalTee.Pos.y - 42 ,0 ,0)
 
	--Game.Ui:DoLabelScaled(Label, "Available Commands:", 15, -1, -1, nil)
	
	-- Real Hud begins here	
	local Screen = Game.Ui:Screen()
	--Engine.Graphics:MapScreen(0,0, Screen.w, Screen.h)

	-- Initialize all needed UIRect's
	local MainView = Screen:copy()
 	--local HUD = UIRect(0, MainView.h - 222, MainView.w, MainView.h)
	local HUD = UIRect(0, MainView.h - (MainView.h/15), MainView.w, MainView.h)
	
 
	Game.RenderTools:DrawUIRect(HUD, vec4f(0,0,0,0.5),  _CUI.CORNER_ALL, 10)
	
	local nextX = scHudDrawProperty("", 1, HUD.x, HUD.y, 18)
	--local nextX = scHudDrawProperty("Bot(F11)", sc_IsScriptEnabled, HUD.x, HUD.y, 18)
	--nextX = nextX + scHudDrawProperty("AimWall(" .. Error .. "Â°)" , UseDD, nextX, HUD.y, 18)
	--nextX = nextX + scHudDrawProperty("FastHook", sc_FastHook, nextX, HUD.y, 18)
	--nextX = nextX + scHudDrawProperty("FastFire", sc_FastFire, nextX, HUD.y, 18)
	--nextX = nextX + scHudDrawProperty("Balance", sc_Balance, nextX, HUD.y, 18)
	--nextX = nextX + scHudDrawProperty("HookRide", sc_ZeroHookVel, nextX, HUD.y, 18)
	--nextX = nextX + scHudDrawProperty("JetRide", sc_JetpackRide, nextX, HUD.y, 18)
	--nextX = nextX + scHudDrawProperty("SpinFire", sc_SpinFire, nextX, HUD.y, 18)
	--nextX = nextX + scHudDrawProperty("HookCol", sc_HookCol, nextX, HUD.y, 18)
	
	nextX = nextX + scHudDrawProperty("TempTest", sc_TempTest, nextX, HUD.y, 18)
	
	local teePosStr = 'Pos:' .. Game.LocalTee.Pos.x .. '    ' .. Game.LocalTee.Pos.y .. '  Vel:' .. Game.LocalTee.Vel.x .. '   ' .. Game.LocalTee.Vel.y
	nextX = nextX + scHudDrawProperty(teePosStr, sc_TempTest, nextX, HUD.y, 18)
	--nextX = nextX + scHudDrawProperty("HookTick " .. Game.LocalTee.HookTick, sc_TempTest, nextX, HUD.y, 18)
	
	

	nextX = nextX + scHudDrawProperty(_debugInfoStr , true, 0, HUD.y + 20, 18)

	--lastHookAimLabel = UIRect(lastHookAimPos.x, lastHookAimPos.y ,0 ,0)
	--if(lastHookAimId ~= -1 ) then 
	--	Game.Ui:DoLabelScaled(lastHookAimLabel, "ID :" .. lastHookAimId  .. "  tick:" .. Game.Client.Tick - RenderedChar[lastHookAimId] , 15, -1, -1, nil)
	--end
	
	--Engine.Graphics:TextureSet(-1)
	--Engine.Graphics:QuadsBegin()
	--	Engine.Graphics:SetColor(128, 111, 0, 0.44)
	--	Game.RenderTools:DrawCircle(lastHookAimPos.x, lastHookAimPos.y, 28, 32)
	--Engine.Graphics:QuadsEnd()
	
	
	
	if(sc_StartRecord == 1) then
		Engine.TextRender:TextColor(1,0,0,1)
		Engine.TextRender:Text(nil, Screen.w/2-100, Screen.h/2-50, 20,"Recording Moves",-1)
		Engine.TextRender:TextColor(1,1,1,1)
	elseif(sc_StartRecord == 2) then
		Engine.TextRender:TextColor(0,1,0,1)
		Engine.TextRender:Text(nil, Screen.w/2-100, Screen.h/2-50, 20,"Playing Moves",-1)
		Engine.TextRender:TextColor(1,1,1,1)	
	end
	
	
	
	

	

	Engine.TextRender:TextColor(1,1,1,1)
 
end

function OriginalKeyPress(Key)
	
 

	if Key == "mouse2" and sc_AutoAimHook == 1 then
		
		--LimitR = 168100
		sc_AimAccuracy = 0.25
		LimitR = (hook_length + 30) * (hook_length + 30)
		Vic = Grab()
	end

	if Key == "mouse1" and sc_AutoAimFire == 1 then
		--LimitR = 10000000
		sc_AimAccuracy = 2
		LimitR = laser_reach * laser_reach 
		Vic = Grab()

		if Game.LocalTee.Weapon == 3 then
			Gup = 1

			if UseG == 0 then
				Vic = -1
			end
		end

		Focus = 1
	end
end


function prn(inp)

	Game.Chat:AddLine(-2, 0,inp)
end

function onScriptDisable()
	sc_LastHookSelectedPlayerId = -1
	lastHookAimPos = vec2(0, 0)
	lastHookAimId = -1

end

setDummy = 0
 
 

function compressFile(inFilename, outFileName)
	local zlib = require('ffi-zlib')

	local f = io.open(inFilename, "rb")
	local out_f = io.open(outFileName, "wb")

	local input = function(bufsize)
		-- Read the next chunk
		local d = f:read(bufsize)
		if d == nil then
			return nil
		end
		return d
	end

	local output_table = {}
	local output = function(data)
		table.insert(output_table, data)
		local ok, err = out_f:write(data)
		if not ok then
			
			-- abort compression when error occurs
			return nil, err
		end
	end

	-- Compress the data
	local ok, err = zlib.deflateGzip(input, output)
	io.close(f)
	io.close(out_f)
	if not ok then
		
		return nil, err
	end

	return table.concat(output_table,'')
end

 


function compressString(inString, outFileName)
	local zlib = require('ffi-zlib')

	--local f = io.open(inFilename, "rb")
	local out_f = io.open(outFileName, "wb")

	local count = 0
	local input = function(bufsize)
		local start = count > 0 and bufsize*count or 1
		local finish = (bufsize*(count+1)-1)
		count = count + 1
		if bufsize == 1 then
			start = count
			finish = count
		end
		local data = inString:sub(start, finish)
		if(#data == 0) then
			return nil
		end
		
		return data
	end


	--local output_table = {} --strOut
	local output = function(data)
		--table.insert(output_table, data) --strOut
		local ok, err = out_f:write(data)
		if not ok then
			
			-- abort compression when error occurs
			return nil, err
		end
	end

	-- Compress the data
	local ok, err = zlib.deflateGzip(input, output)
	--io.close(f)
	io.close(out_f)
	if not ok then
		
		return nil, err
	end
	return ok
	--return table.concat(output_table,'') --strOut
end


function decompressFile(fileName)
	local zlib = require('ffi-zlib')

	local f = io.open(fileName, "rb")
	--local out_f = io.open('ex.exe', "wb")

	local input = function(bufsize)
		-- Read the next chunk
		local d = f:read(bufsize)
		if d == nil then
			return nil
		end
		return d
	end

	local output_table = {}
	local output = function(data)
		table.insert(output_table, data)
		--local ok, err = out_f:write(data)
		--if not ok then
		--	return nil, err
		--end
	end

	-- Decompress the data
	local ok, err = zlib.inflateGzip(input, output)
	
	io.close(f)
	--io.close(out_f)
	
	if not ok then
		return nil
	end

	return table.concat(output_table,'')
end

 
function decodeChar(hex)
	return string.char(tonumber(hex,16))
end
 
function decodeString(str)
	local output, t = string.gsub(str,"%%(%x%x)",decodeChar)
	return output
end
 
function encodeChar(chr)
	return string.format("%%%X",string.byte(chr))
end
 
function encodeString(str)
	local output, t = string.gsub(str,"[^%w]",encodeChar)
	return output
end



function findRecAtPos(inPos, inDistance)
	for i=1,#availRecPosArray,1 do
		
		if(Game.Collision:Distance(vec2(availRecPosArray[i].x, availRecPosArray[i].y), inPos) <= inDistance) then			
			local binary_data = decompressFile(availRecPosArray[i].dir .. '/' .. availRecPosArray[i].fullName)
			return bitser.loads(binary_data)
		end	
	end
	return {}
end

function deleteRecAtPos(inPos)
	for i=1,#availRecPosArray,1 do
		
		if(Game.Collision:Distance(vec2(availRecPosArray[i].x, availRecPosArray[i].y), inPos) <= 0) then
			fs.remove(availRecPosArray[i].dir .. '/' .. availRecPosArray[i].fullName)
			resetAvailableRecord()
			return true
		end	
	end
	return false
end

function saveARec(inPlayBackArray)
	finalFileName = Game.Players(Game.LocalCID).Name .. '_' .. 
				round2(inPlayBackArray[1].TeePosX) .. '_' ..
				round2(inPlayBackArray[1].TeePosY) .. '_' ..
				os.date("%y%m%d") .. '_' ..
				os.date("%H%M%S") .. '_' ..
				'Rez1' .. '_' ..
				'Rez2' .. '_' ..
				'Rez3'
				
	local binary_data = bitser.dumps(inPlayBackArray)
	--local copy_of_some_thing = bitser.loads(binary_data)
	--prn( encodeString(finalFileName) )
	compressString(binary_data, 'rec/' .. encodeString(Game.ServerInfo.Map) .. '/' .. encodeString(finalFileName) )
	
	resetAvailableRecord()
end

function isAltDown()
	return Engine.Input:KeyIsPressed("lalt") or Engine.Input:KeyIsPressed("ralt")
end


function isCtrlDown()
	return Engine.Input:KeyIsPressed("lctrl") or Engine.Input:KeyIsPressed("rctrl")
end



function isShiftDown()
	return Engine.Input:KeyIsPressed("lshift") or Engine.Input:KeyIsPressed("rshift")
end

function OnKeyPress(Key)
	--mousewheeldown
	--mousewheelup
	--mouse3
 

	--prn('key : ' .. Key)
--	if(Key == 'f11') then
--		sc_IsScriptEnabled = 1 - sc_IsScriptEnabled
--		if(sc_IsScriptEnabled ~= 1) then onScriptDisable() end
	if(Key == 'mouse3' and sc_PlaybackBot == 1) then
		if(isAltDown() and isCtrlDown() and isShiftDown()) then
			--local exactRec = 
			if(deleteRecAtPos(Game.LocalTee.Pos)) then --there is a record EXACTLY here
				prn('Deleted record')
			else
				prn('Cand find any record to delete at this position!')
			end
			
		elseif(isCtrlDown() and not isAltDown() and not isShiftDown()) then
			if(sc_StartRecord == 0) then  --currently nothing
				local exactRec = findRecAtPos(Game.LocalTee.Pos, 0)
				if(#exactRec > 0) then --there is a record EXACTLY here
					sc_playbackArray = exactRec
					sc_StartRecord = 2
					sc_sendPlaybackCount = 1
					prn('Playing record!')
					return
				end
				
				nearRec = findRecAtPos(Game.LocalTee.Pos, 34)
				if(#nearRec > 0) then
					prn('You cant start record near another record position')
				else
					sc_playbackArray = {}
					sc_StartRecord = 1
					prn('Recording started!')
					--sc_sendPlaybackCount = 1
				end
				
			elseif(sc_StartRecord == 1) then  --currently recording
				sc_StartRecord = 0
				saveARec(sc_playbackArray)
				prn('Recording stopped and saved!')
				
			elseif(sc_StartRecord == 2) then --currently playing a playback
				sc_StartRecord = 0
				sc_sendPlaybackCount = 1
			end
		 
		
		end
	
	elseif(sc_HookrideBot == 1 and Key.lower(Key) == _ConfigGet("HookRideKey"):lower()) then
		if(isAltDown() and not isCtrlDown() and not isShiftDown()) then
			sc_ZeroHookVel = 1 - sc_ZeroHookVel				
			WantedPos = Game.LocalTee.Pos
		end
		
	elseif sc_JetrideBot == 1 and Key.lower(Key) == _ConfigGet("JetRideKey"):lower() then
		if(isAltDown() and not isCtrlDown() and not isShiftDown()) then
			sc_JetpackRide = 1 - sc_JetpackRide
			if(sc_JetpackRide == 0) then Game.Input.Fire = 0 end --prevent bug continues shoot after disable
			WantedPos = Game.LocalTee.Pos
		end
			
	 
	elseif(Key == 'f9') then
		--Game.Input.DummyFire = (Game.Input.DummyFire + 1) % 2
		--Game.Input.DummyFire = (Game.Input.DummyFire + 1) % 2
		--Game.Input.DummyDirection = 1
		if(sc_IsFullScreen) then
			ExitFullscreen()
		else
			EnterFullscreen()
			
		end

		--prn('id1: ' .. Game.MainID .. '    id2:' .. Game.DummyID .. '    LocalCID:' .. Game.LocalCID	)
		
		--Engine.Input:MouseModeRelative()
		--Engine.Input:MouseModeAbsolute()
	
	
	
		--LastLinePos = Game.LocalTee.Pos
		--nDir = normalize(vec2(Game.Input.MouseX, Game.Input.MouseY)) * hook_length
		--local colPos = vec2(0,0)
		--local beforeColPos = vec2(0,0)
		--local nres = vec2(LastLinePos.x + nDir.x, LastLinePos.y + nDir.y)
		--
		--if(Game.Collision:IntersectLine(LastLinePos, nres, colPos, beforeColPos, false) ~= 0) then
		--	--be yechi khorde
		--	
		--	
		--			
		--	--MovePointPos = vec2(Game.LocalTee.Pos.x, Game.LocalTee.Pos.y)
        --
		--	--Game.Collision:MoveBox(pos11, vel11, vec2(28,28), 1);
		--	
		--end
		--
		--
		--			MovePointPos = Game.LocalTee.Pos
		--	vel11 = colPos - LastLinePos
		--	Game.Collision:MovePoint(MovePointPos,vel11, 1, nil)
		--	
		--	prn(MovePointPos.x .. '  ' .. MovePointPos.y .. '    ' .. vel11.x  .. '    ' .. vel11.y)

		 
		

		
	end
	
	
	if(sc_IsScriptEnabled ~= 1) then return end
	

	
	OriginalKeyPress(Key)
	 
		
	if(Key == 'mouse2') then
		tickCountOfPlayerHook = 0
		
	elseif(Key == 'mouse1') then
		HandleMenuClicks()
		
		
	elseif(Key == 'f8') then
		--Config.cl_dummy = 1 - Config.cl_dummy	
		
		setDummy = 1
		
	end
	
	 

	--state check end
	
	return 
end



function Fly()
	if(sc_JetpackRide == 0 and sc_ZeroHookVel == 0) then 
		return
	end
	
	local eachMoveStep = 4
	local moveSensivity = eachMoveStep * 1
	
	if Engine.Input:KeyIsPressed("a") then
		WantedPos.x = WantedPos.x - eachMoveStep
	end

	if Engine.Input:KeyIsPressed("d") then
		WantedPos.x = WantedPos.x + eachMoveStep
	end

	if Engine.Input:KeyIsPressed("w") then
		WantedPos.y = WantedPos.y - eachMoveStep
	end

	if Engine.Input:KeyIsPressed("s") then
		WantedPos.y = WantedPos.y + eachMoveStep
	end

	local Priority = math.abs(Game.LocalTee.Pos.y - WantedPos.y)/6.685

	if Priority < 1 then
		Priority = 1
	end

	if WantedPos.y < Game.LocalTee.Pos.y then
		VMod = Priority*-0.75
	elseif Game.LocalTee.Pos.y < WantedPos.y then
		VMod = Priority*0.75
	else
		VMod = 0
	end

	if VMod < Game.LocalTee.Vel.y then
		if(sc_JetpackRide == 1) then
			Game.Input.TargetX = 0
			Game.Input.TargetY = 1
		
			Game.Input.Fire = 1
		elseif(sc_ZeroHookVel == 1) then
			Game.Input.Hook = 1
		end
		
	else
		if(sc_JetpackRide == 1) then
			Game.Input.Fire = 0
		elseif(sc_ZeroHookVel == 1) then
			Game.Input.Hook = 0
		end
	end

	if Game.LocalTee.Pos.x - WantedPos.x < -moveSensivity then
		Game.Input.Direction = 1
	elseif moveSensivity < Game.LocalTee.Pos.x - WantedPos.x then
		Game.Input.Direction = -1
	else
		Game.Input.Direction = 0
	end

	return 
end

function OriginalOnKeyRelease(Key)
	if Key == "mouse1" then
		Focus = 0
	end
	


	Vic = -1
end

function OnKeyRelease(Key)
	if(sc_IsScriptEnabled ~= 1) then return end
	
	OriginalOnKeyRelease(Key)

 
	return 
end

function Tar(x, y, xx, yy, Rly)
	local ax = xx - x
	local ay = yy - y
	local ac = Dis(x, y, xx, yy)
	local sx = x + ax/ac*TeeTall
	local sy = y + ay/ac*TeeTall
	local Us = Game.LocalTee.Pos
	local Them = Game.LocalTee.Pos
	Us.x = sx
	Us.y = sy
	Them.x = xx
	Them.y = yy

	--local tRes =Game.Collision:IntersectLine(Us, Them, nil, nil, false)
	--if(tRes ~= 0 and tRes ~= 1 and tRes ~= 3) then
	--	prn("a: " .. Game.Collision:IntersectLine(Us, Them, nil, nil, false))
	--end 
	if Game.Collision:IntersectLineTeleHook(Us, Them, nil, nil, false) == 0 then
		if Rly == 1 then
			if Gup == 1 then
				local Zav = math.deg(math.atan(ay/ax))

				if 0 < Zav then
					Zav = Zav*-1
				end

				Zav = Zav + 90.001
				Zav = math.sqrt(Zav)
				local Fas = (40 - ac )*(40 - ac)
				local Ini = 20
				Gup = Ini - Fas*Zav*Con

				if Shutup%2 == 1 then
					Game.Chat:Say(0, Zav)
					print(Zav)
				end
			end

			Game.Input.TargetX = xx - x
			Game.Input.TargetY = yy - y + Gup
		end

		return 1
	end

	return 0
end


function round2(num, numDecimalPlaces)
  return tonumber(string.format("%." .. (numDecimalPlaces or 0) .. "f", num))
end



function SetAim(Who, Rly)
	local anax, anay, anaxx, anayy = nil
	local anax = LPosx()
	local anay = LPosy()
	local anaxx = Posx(Who)
	local anayy = Posy(Who)
	
	local foundARad = 0
	local foundBRad = 0
	local startRad = -1
	local endRad = -1
	
	
	for TeeRad = 0, TeeRadConst, sc_AimAccuracy do
		if  Tar(anax, anay, anaxx - TeeRad, anayy - TeeRad, Rly) == 0 and Tar(anax, anay, anaxx - TeeRad, anayy + TeeRad, Rly) == 0 and Tar(anax, anay, anaxx + TeeRad, anayy - TeeRad, Rly) == 0 and Tar(anax, anay, anaxx + TeeRad, anayy + TeeRad, Rly) == 0 then
			if Rly == 1 and UseDD == 1 then
				Game.Input.TargetX = anaxx - anax
				Game.Input.TargetY = anayy - anay
			end
			--return 0
		else
			foundARad = 1
			startRad = TeeRad
			break
		end
	end
	
	for TeeRad = TeeRadConst, 0, -sc_AimAccuracy do
		if  Tar(anax, anay, anaxx - TeeRad, anayy - TeeRad, Rly) == 0 and Tar(anax, anay, anaxx - TeeRad, anayy + TeeRad, Rly) == 0 and Tar(anax, anay, anaxx + TeeRad, anayy - TeeRad, Rly) == 0 and Tar(anax, anay, anaxx + TeeRad, anayy + TeeRad, Rly) == 0 then
			if Rly == 1 and UseDD == 1 then
				Game.Input.TargetX = anaxx - anax
				Game.Input.TargetY = anayy - anay
			end
			--return 0
		else
			foundBRad = 1
			endRad = TeeRad
			break
		end
	end
	
	
	if( foundBRad == 1 and foundARad == 1) then
		TeeRad = ((startRad + endRad)/2)
		--prn(startRad .. "     " .. endRad .. "      " .. TeeRad)
		if  Tar(anax, anay, anaxx - TeeRad, anayy - TeeRad, Rly) == 0 and Tar(anax, anay, anaxx - TeeRad, anayy + TeeRad, Rly) == 0 and Tar(anax, anay, anaxx + TeeRad, anayy - TeeRad, Rly) == 0 and Tar(anax, anay, anaxx + TeeRad, anayy + TeeRad, Rly) == 0 then
			if Rly == 1 and UseDD == 1 then
				Game.Input.TargetX = anaxx - anax
				Game.Input.TargetY = anayy - anay
			end
			--return 0
		end
		
	end
	
	return foundBRad
end

function InRange(Who)
	local rxx = LPosx() - Posx(Who)
	local ryy = LPosy() - Posy(Who)

	if rxx*rxx + ryy*ryy <= 168100 then
		return 1
	end

	return 0
end
dirReverse = 0



dummyTick = 0



function meanAngle (angleList)
  local sumSin, sumCos = 0, 0
  for i, angle in pairs(angleList) do
    sumSin = sumSin + math.sin(math.rad(angle))
    sumCos = sumCos + math.cos(math.rad(angle))
  end
  local result = math.deg(math.atan2(sumSin, sumCos))
  return string.format("%.2f", result)
end
 

 


 
sc_StartRecord = 0
sc_playbackArray = {}
sc_sendPlaybackCount = 1

function OnSnapInput()
	--local res = Game.Collision:TestBox(Game.LocalTee.Pos, vec2(28,28))
	--if(res) then prn('YES') end
	
	
	if(sc_StartRecord == 2) then
		if(sc_sendPlaybackCount <= #sc_playbackArray) then
			Game.Input.Direction = sc_playbackArray[sc_sendPlaybackCount].Direction
			Game.Input.Fire = sc_playbackArray[sc_sendPlaybackCount].Fire
			Game.Input.Hook = sc_playbackArray[sc_sendPlaybackCount].Hook
			Game.Input.Jump = sc_playbackArray[sc_sendPlaybackCount].Jump
			Game.Input.WantedWeapon = sc_playbackArray[sc_sendPlaybackCount].WantedWeapon
			Game.Input.TargetX = sc_playbackArray[sc_sendPlaybackCount].TargetX
			Game.Input.TargetY = sc_playbackArray[sc_sendPlaybackCount].TargetY
			sc_sendPlaybackCount = sc_sendPlaybackCount + 1
		else
			sc_sendPlaybackCount = 1
			sc_StartRecord = 0
			
			
			--if autoplayback
			local exactRec = findRecAtPos(Game.LocalTee.Pos, 0)
			if(#exactRec > 0) then --there is a record EXACTLY here
				sc_playbackArray = exactRec
				sc_StartRecord = 2
				sc_sendPlaybackCount = 1
				prn('Auto continue record!')
				return
			end
			
		end
		return
	end	 

		
	Fly()
	--if(rec == true) then
	--	table.insert(Lines, LineItem(LastLinePos.x, LastLinePos.y, nres.x, nres.y))
	--end
	--if(setDummy == 1) then
	--	Config.cl_dummy = 1 - Config.cl_dummy
	--	Game.Input.Fire = (Game.Input.Fire + 1)%2
	--	setDummy = 2
	--elseif(setDummy == 2) then
	--	Config.cl_dummy = 1 - Config.cl_dummy
	--	Game.Input.Fire = (Game.Input.Fire + 1)%2
	--	setDummy = 0
	--end
	--if(Game.LocalTee.Pos.y == 9809) then
	--	_debugInfoStr = ""
	--end
	--if( math.abs(Game.LocalTee.Pos.y - 10924) < 10 and Game.Input.Hook == 0) then
		--Game.Input.TargetX = -17
		--Game.Input.TargetY = -294
		--Game.Input.Hook = 1
	--end
	--if(Game.Input.Hook == 1 and string.len(_debugInfoStr) == 0 ) then
	--	_debugInfoStr = "x: " .. Game.LocalTee.Pos.x .. "   y: " .. Game.LocalTee.Pos.y .. "    tx:" .. Game.Input.TargetX .. "   ty:" .. Game.Input.TargetY
	--end
	
	if(sc_IsScriptEnabled ~= 1) then return end
	dirReverse = dirReverse + 1

	dummyTick = dummyTick + 1
	--if(dummyTick % 50 == 49) then
	--	Config.cl_dummy = 1 - Config.cl_dummy
	--end
	if(sc_AutoAimFire == 1 or sc_AutoAimHook == 1) then
		Grab() --colorize the hookable tee
	else 
		lastHookAimId = -1
	end
	
	HaltLook = 0

	if Focus == 0 and Game.LocalTee.HookedPlayer ~= -1 then
		HaltLook = 1
	end

	if Vic ~= -1 and HaltLook == 0 then
		SetAim(Vic, 1)
	end

	Gup = 0

	
	
	if(Engine.Input:KeyIsPressed("mouse2") and sc_FastHook == 1 ) then
		tickCountOfPlayerHook = tickCountOfPlayerHook + 1
		if(tickCountOfPlayerHook % 4 == 0 and Game.LocalTee.HookedPlayer == -1 ) then
			tickCountOfPlayerHook = 0
			if(Game.Input.Hook == 1) then
				Game.Input.Hook = 0
			else 
				OriginalKeyPress('mouse2')
				Game.Input.Hook = 1
			end
			
		end
	end
	 
	if(Engine.Input:KeyIsPressed("mouse1") and sc_FastFire == 1) then
		Game.Input.Fire = (Game.Input.Fire + 1) % 2
	end
	
	if(sc_DummyHookFly == 1) then
		--Game.MainID .. '    id2:' .. Game.DummyID
		if((Game.Client:DummyConnected())) then
			
			local MainPos = Game.LocalTee.Pos
			local DummyPos = Game.Players(Game.DummyID).Tee.Pos
			
			if(Config.cl_dummy == 1 ) then
				DummyPos = Game.Players(Game.MainID).Tee.Pos
			end

			local mdDir = MainPos - DummyPos			
			if(DummyPos.y < MainPos.y and Game.Collision:Distance(DummyPos, MainPos) > 16) then
				Game.Input.DummyTargetX = mdDir.x
				Game.Input.DummyTargetY = mdDir.y
				Game.Input.DummyHook = 1
			else
				Game.Input.DummyHook = 0
			end

			--if(((CGameClient *)GameClient())->m_aClients[m_LocalIDs[!g_Config.m_ClDummy]].m_Predicted.m_HookState == HOOK_RETRACTED || distance(Dummy, Main) < 48)
			if(Game.Collision:Distance(DummyPos, MainPos) < 48) then
				Game.Input.DummyHook = 0
			end
			
		end
		
	end
	 
	 
	if( sc_AutoHammerFly == 1) then
	
		local MainPos = Game.LocalTee.Pos
		local DummyPos = Game.Players(Game.DummyID).Tee.Pos
		
		if(Config.cl_dummy == 1 ) then
			DummyPos = Game.Players(Game.MainID).Tee.Pos
		end
		
		
 
		--	Game.Input.DummyFire = (Game.Input.DummyFire + 1) % 10
		--	local lookDeg = MainPos - DummyPos
		--	Game.Input.DummyTargetX = lookDeg.x
		--	Game.Input.DummyTargetY = lookDeg.y
 

		local setHookState = false
		if(Game.LocalTee.HookState == HOOK_RETRACTED) then
			Game.Input.Hook = 0
			setHookState = true
		elseif(Game.LocalTee.HookState == HOOK_GRABBED and Game.LocalTee.HookedPlayer ~= Game.MainID and Game.LocalTee.HookedPlayer ~= Game.DummyID) then
			Game.Input.Hook = 0
			setHookState = true			
		end
		
		if( not setHookState) then
			Game.Input.Hook = 1
			local lookDeg2 = DummyPos - MainPos
			Game.Input.TargetX = lookDeg2.x
			Game.Input.TargetY = lookDeg2.y
		end
	end
 
	if(sc_TempTest == 1) then
		


 
 --Game.Input.Fire = (Game.Input.Fire + 1) % 10
		
		--Game.Input.DummyDirection    = Game.Input.Direction     
		--Game.Input.DummyFire         = Game.Input.Fire - lastInputData[Config.cl_dummy].Fire          
		--Game.Input.DummyHook         = Game.Input.Hook          
		--Game.Input.DummyJump         = Game.Input.Jump          
		--Game.Input.DummyWantedWeapon = Game.Input.WantedWeapon  
		--Game.Input.DummyTargetX      = Game.Input.TargetX       
		--Game.Input.DummyTargetY      = Game.Input.TargetY       
		
		
	end
	
	
	--if(XYLaser ~= nil) then
	--	XYLaser = XYLaser * 100
	--	Game.Input.TargetX = XYLaser.x
	--	Game.Input.TargetY = XYLaser.y
	--	Game.Input.Fire = Game.Input.Fire + 1
	--	XYLaser = nil
	--else
	--	Game.Input.Fire = 0
	--end
	 
	
	
	if(sc_HookCol == 1 and Game.Input.Hook == 1) then

	
		local HookLenLimit = 42 + 17 --42 = teetall and 16 half of a tile to reach its center
		local colPos = vec2(0,0)
		local beforeColPos = vec2(0,0)
 
		local startCol = nil
		local endCol = nil
		 
		
		local HookStartPos = Game.LocalTee.Pos + GetDir( HeadVectorToRadian(Game.Input.MouseX, Game.Input.MouseY)) * 28 * 1.5
		
		local dirOfHook = GetDir( HeadVectorToRadian(Game.Input.MouseX, Game.Input.MouseY)) * (hook_length - HookLenLimit)
		local hookPos = HookStartPos + dirOfHook
		local hokColTile = Game.Collision:IntersectLineTeleHook(HookStartPos, hookPos, colPos, beforeColPos, false) 
		
		
		--prn(' hokColTile: ' .. hokColTile)
		if(hokColTile == 3 or hokColTile == 0) then
			
			local positiveDeg = nil
			local negativeDeg = nil
			for degI = 0, 40, 0.1 do
				dirOfHook = GetDir( HeadVectorToRadian(Game.Input.MouseX, Game.Input.MouseY) + (const_degInRad * degI)) * (hook_length - HookLenLimit)
				hookPos = HookStartPos + dirOfHook
				hokColTile = Game.Collision:IntersectLineTeleHook(HookStartPos, hookPos, colPos, beforeColPos, false)
				
				if(hokColTile == 1) then
					positiveDeg = degI
					break
				end
					
			end		
			for degI = 0, -40, -0.1 do
				dirOfHook = GetDir( HeadVectorToRadian(Game.Input.MouseX, Game.Input.MouseY) + (const_degInRad * degI)) * (hook_length - HookLenLimit)
				hookPos = HookStartPos + dirOfHook
				hokColTile = Game.Collision:IntersectLineTeleHook(HookStartPos, hookPos, colPos, beforeColPos, false)
				
				if(hokColTile == 1) then
					negativeDeg = degI
					break
				end
					
			end
			
			--if(positiveDeg ~= nil) then prn( 'PD:' .. positiveDeg) end
			--if(negativeDeg ~= nil) then prn( 'ND:' .. negativeDeg) end
			
			local forSt = 1
			local forEd = 0
			local forSp = 1
			
			if(positiveDeg ~= nil and negativeDeg ~= nil) then
				if(math.abs(positiveDeg) < math.abs(negativeDeg)) then
					forSt = positiveDeg + 10
					forEd = positiveDeg
					forSp = -0.1
				else
					forSt = negativeDeg - 10
					forEd = negativeDeg
					forSp = 0.1
				end
				
			elseif(positiveDeg ~= nil or negativeDeg ~= nil) then
				if(positiveDeg ~= nil) then
					forSt = positiveDeg 
					forEd = positiveDeg + 10
					forSp = 0.1
				elseif(negativeDeg ~= nil) then
					forSt = negativeDeg
					forEd = negativeDeg - 10
					forSp = -0.1
				end
			end
			
			--_debugInfoStr = "forSt:"  .. forSt .. "  forEd:" .. forEd .. " forSp:" .. forSp .. "  "
			--prn(_debugInfoStr)
			--_debugInfoStr = ""
			for degI = forSt, forEd, forSp do
				dirOfHook = GetDir( HeadVectorToRadian(Game.Input.MouseX, Game.Input.MouseY) + (const_degInRad * degI)) * (hook_length - HookLenLimit)
				hookPos = HookStartPos + dirOfHook
				hokColTile = Game.Collision:IntersectLineTeleHook(HookStartPos, hookPos, colPos, beforeColPos, false)
				
				--prn('degI : ' .. degI)
				if(hokColTile == 1) then
					--prn('DONE')
					if(startCol == nil) then
						
						--_debugInfoStr = _debugInfoStr .. degI .. "<d1    d2>"
						
						startCol = vec2( colPos.x, colPos.y)
					end
					endCol = vec2( colPos.x, colPos.y) 
				else
					--break
				end
				
			 
			end 
			--prn( 'startCol:' .. round2(startCol.x,2) .. '    ' .. round2(startCol.y,2) .. '   endCol' .. round2(endCol.x,2) .. '     ' .. round2(endCol.y,2) )
			if(startCol ~= nil and endCol ~= nil ) then
				
				
				local sd = startCol - Game.LocalTee.Pos
				local sdRad = HeadVectorToRadian(sd.x, sd.y)
				
				local sd2 = endCol - Game.LocalTee.Pos
				local sdRad2 = HeadVectorToRadian(sd2.x, sd2.y) 
				
				
				local tempPrnDeg = ((sdRad2 + sdRad)/2)*180/PI
				--local newTempPrnRad = meanAngle({350, 10})
				--prn('s:'  .. round2(sdRad,2) .. '   e:' .. round2(sdRad2,2) .. "   deg:" .. round2(tempPrnDeg,1) .. ' ((sdRad2 + sdRad)/2):' .. round2((sdRad2 + sdRad)/2,2) )
				
				if( (sdRad < 0 and sdRad2 > 0) or (sdRad > 0 and sdRad2 < 0) ) then --if both have different signs then bug occurs we have to add one full circle 2PI to only one of them
					sdRad = sdRad + (PI * 2)
					--sdRad2 = sdRad2 + (PI * 2)
					--prn('BUG')
				end
				--if( math.abs((sdRad2 + sdRad)/2) < 0.1 ) then
				--	sdRad = sdRad + PI
				--	sdRad2 = sdRad2 + PI
				--end
				
				
				--prn('s:'  .. round2(sdRad,1) .. '   e:' .. round2(sdRad2,1) .. "   deg:" .. round2(tempPrnDeg,1))
				dirOfHook = GetDir( (sdRad2 + sdRad)/2) * hook_length

				Game.Input.TargetX = dirOfHook.x
				Game.Input.TargetY = dirOfHook.y
			end
		end
    end
		
	
	if(sc_SpinFire == 1 and Engine.Input:KeyIsPressed("mouse1")) then
		if(not Engine.Input:KeyIsPressed("mouse2")) then
			local testDir = normalize( vec2(math.sin(Game.Client.LocalTime*5 ), math.cos(Game.Client.LocalTime*5 ))) * 1000
			Game.Input.TargetX = testDir.x
			Game.Input.TargetY = testDir.y
			if(sc_FastFire == 0) then
				Game.Input.Fire = (Game.Input.Fire + 1) % 2
			end
		end
	end
	
	
	
	
	if(sc_Balance == 1) then
		if (sc_LastHookSelectedPlayerId ~= nil and sc_LastHookSelectedPlayerId >= 0) then 
			-- is anybody selected? Can we get to him?
			if(Game.Collision:IntersectLine(Game.LocalTee.Pos, Game.Players(sc_LastHookSelectedPlayerId).Tee.Pos, nil, nil, false) == 0) then				
				if(Game.LocalTee.Pos.x - Game.Players(sc_LastHookSelectedPlayerId).Tee.Pos.x > 2) then
					Game.Input.Direction = -1
				elseif(Game.Players(sc_LastHookSelectedPlayerId).Tee.Pos.x - Game.LocalTee.Pos.x > 2) then
					Game.Input.Direction = 1
				
				end
			end
			 
		end
		 
	end
	
	
	if(sc_StartRecord == 1) then
		sc_sendPlaybackCount = 1
		sc_playbackArray[#sc_playbackArray+1] = {
			Direction = Game.Input.Direction,
			Fire = Game.Input.Fire,
			Hook = Game.Input.Hook,
			Jump = Game.Input.Jump,
			WantedWeapon  = Game.Input.WantedWeapon,
			TargetX  = Game.Input.TargetX,
			TargetY  = Game.Input.TargetY,
			TeePosX = Game.LocalTee.Pos.x,
			TeePosY = Game.LocalTee.Pos.y,
		}
	end
	--

	if(sc_StartRecord == 0 and sc_dummy_copy == 1) then


		Game.Input.DummyDirection    = Game.Input.Direction     
		Game.Input.DummyFire         = Game.Input.Fire - lastInputData[Config.cl_dummy].Fire          
		Game.Input.DummyHook         = Game.Input.Hook          
		Game.Input.DummyJump         = Game.Input.Jump          
		Game.Input.DummyWantedWeapon = Game.Input.WantedWeapon  
		Game.Input.DummyTargetX      = Game.Input.TargetX       
		Game.Input.DummyTargetY      = Game.Input.TargetY       
		--Game.Input.DummyMouseX       = Game.Input.MouseX        
		--Game.Input.DummyMouseY       = Game.Input.MouseY        
		Game.Input.DummyNextWeapon		= Game.Input.NextWeapon - lastInputData[Config.cl_dummy].NextWeapon
		Game.Input.DummyPreviousWeapon	= Game.Input.PreviousWeapon - lastInputData[Config.cl_dummy].PreviousWeapon
		--flag copy missing
		if(sc_dummy_mirrorX == 1) then Game.Input.DummyTargetX = -Game.Input.DummyTargetX end
		if(sc_dummy_mirrorY == 1) then Game.Input.DummyTargetY = -Game.Input.DummyTargetY end
		if(sc_dummy_direction == 1) then Game.Input.DummyDirection = -Game.Input.DummyDirection end
		--m_InputData[g_Config.m_ClDummy].m_FCount - m_LastData[g_Config.m_ClDummy].m_FCount;
	
	end
	
	lastInputData[Config.cl_dummy] = {
		Direction       = Game.Input.Direction, 
		Fire            = Game.Input.Fire, 
		Hook            = Game.Input.Hook, 
		Jump            = Game.Input.Jump, 
		WantedWeapon    = Game.Input.WantedWeapon, 
		TargetX         = Game.Input.TargetX, 
		TargetY         = Game.Input.TargetY, 
		MouseX          = Game.Input.MouseX, 
		MouseY          = Game.Input.MouseY, 
		Flags  			= Game.Input.Flags,
		NextWeapon		= Game.Input.NextWeapon,
		PreviousWeapon	= Game.Input.PreviousWeapon
	}
	
	
	
	lastInputData[1 - Config.cl_dummy] = {
		Direction       = Game.Input.DummyDirection, 
		Fire            = Game.Input.DummyFire, 
		Hook            = Game.Input.DummyHook, 
		Jump            = Game.Input.DummyJump, 
		WantedWeapon    = Game.Input.DummyWantedWeapon, 
		TargetX         = Game.Input.DummyTargetX, 
		TargetY         = Game.Input.DummyTargetY, 
		MouseX          = Game.Input.DummyMouseX, 
		MouseY          = Game.Input.DummyMouseY, 
		Flags  			= Game.Input.DummyFlags,
		NextWeapon		= Game.Input.DummyNextWeapon,
		PreviousWeapon	= Game.Input.DummyPreviousWeapon
	}
	

	
	return 
end

function OnKill(Sword, Shield, Weapon)
	if(sc_IsScriptEnabled ~= 1) then return end
	
	--Game.Players(Shield).Tee.Pos.x = 1000000
	--Game.Players(Shield).Tee.Pos.y = 1000000

	return 
end



RegisterEvent("OnKill", "OnKill")
RegisterEvent("OnEnterGame", "OnEnterGame")
RegisterEvent("OnChat", "OnChat")
RegisterEvent("OnConsoleCommand", "OnConsoleCommand")
RegisterEvent("OnKeyPress", "OnKeyPress")
RegisterEvent("OnSnapInput", "OnSnapInput")
RegisterEvent("OnKeyRelease", "OnKeyRelease")
RegisterEvent("OnRenderLevel14", "Render")
RegisterEvent("OnRenderLevel22", "RenderFullscreen")

return 
